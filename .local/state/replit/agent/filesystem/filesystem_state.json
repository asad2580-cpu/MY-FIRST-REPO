{"file_contents":{"app.py":{"content":"import streamlit as st\nimport json\nimport os\nfrom datetime import datetime\nfrom PIL import Image\nimport io\nfrom pdf2image import convert_from_bytes\nfrom transaction_extractor import TransactionExtractor\nfrom tally_xml_generator import TallyXMLGenerator\nfrom gst_processor import GSTProcessor\nfrom invoice_extractor import InvoiceExtractor\nfrom invoice_xml_generator import InvoiceXMLGenerator\nfrom gst_portal_json_generator import GSTPortalJSONGenerator\nfrom gst_tally_xml_generator import GSTTallyXMLGenerator\nfrom gstr2b_dedicated_processor import GSTR2BDedicatedProcessor\nfrom gstr2b_masters_xml import GSTR2BMastersXMLGenerator\nfrom gstr2b_transactions_xml import GSTR2BTransactionsXMLGenerator\n\n# Set page configuration\nst.set_page_config(\n    page_title=\"Tally ERP Automation Suite\",\n    page_icon=\"ğŸ›ï¸\",\n    layout=\"wide\"\n)\n\ndef convert_file_to_png_bytes(uploaded_file) -> bytes:\n    \"\"\"\n    Convert uploaded file (PNG, JPG, JPEG, PDF) to PNG bytes.\n    \n    Args:\n        uploaded_file: Streamlit UploadedFile object\n        \n    Returns:\n        PNG image bytes\n    \"\"\"\n    file_bytes = uploaded_file.read()\n    file_extension = uploaded_file.name.lower().split('.')[-1]\n    \n    try:\n        if file_extension == 'pdf':\n            # Convert PDF to images (take first page)\n            images = convert_from_bytes(file_bytes, first_page=1, last_page=1, dpi=200)\n            if images:\n                # Convert PIL Image to PNG bytes\n                img_bytes = io.BytesIO()\n                images[0].save(img_bytes, format='PNG')\n                return img_bytes.getvalue()\n            else:\n                raise ValueError(\"No images found in PDF\")\n        \n        elif file_extension in ['jpg', 'jpeg']:\n            # Convert JPG/JPEG to PNG\n            image = Image.open(io.BytesIO(file_bytes))\n            # Convert to RGB if needed (JPEG can be in different modes)\n            if image.mode != 'RGB':\n                image = image.convert('RGB')\n            img_bytes = io.BytesIO()\n            image.save(img_bytes, format='PNG')\n            return img_bytes.getvalue()\n        \n        elif file_extension == 'png':\n            # Already PNG, return as-is\n            return file_bytes\n        \n        else:\n            raise ValueError(f\"Unsupported file format: {file_extension}\")\n            \n    except Exception as e:\n        raise Exception(f\"Error converting {file_extension.upper()} file: {str(e)}\")\n\n# Initialize the transaction extractor\n@st.cache_resource\ndef get_extractor():\n    return TransactionExtractor()\n\ndef main():\n    st.title(\"ğŸ›ï¸ Tally ERP Automation Suite\")\n    st.markdown(\"Comprehensive automation solution for importing bank statements, invoices, and GST returns into Tally\")\n    \n    # Check if API key is available\n    api_key = os.environ.get(\"GEMINI_API_KEY\")\n    if not api_key:\n        st.error(\"âš ï¸ GEMINI_API_KEY environment variable not found. Please set your Gemini API key.\")\n        st.stop()\n    \n    # Global Configuration Section\n    st.subheader(\"âš™ï¸ Company Configuration\")\n    col_config1, col_config2 = st.columns(2)\n    \n    with col_config1:\n        company_name = st.text_input(\n            \"Company Name (as in Tally)\",\n            placeholder=\"Enter your company name exactly as it appears in Tally\",\n            help=\"This should match your company name in Tally exactly\"\n        )\n    \n    with col_config2:\n        company_state = st.selectbox(\n            \"Company State\",\n            options=[\n                \"Andhra Pradesh\", \"Arunachal Pradesh\", \"Assam\", \"Bihar\", \"Chhattisgarh\", \"Goa\", \"Gujarat\", \"Haryana\",\n                \"Himachal Pradesh\", \"Jharkhand\", \"Karnataka\", \"Kerala\", \"Madhya Pradesh\", \"Maharashtra\", \"Manipur\",\n                \"Meghalaya\", \"Mizoram\", \"Nagaland\", \"Odisha\", \"Punjab\", \"Rajasthan\", \"Sikkim\", \"Tamil Nadu\",\n                \"Telangana\", \"Tripura\", \"Uttar Pradesh\", \"Uttarakhand\", \"West Bengal\", \"Delhi\", \"Puducherry\"\n            ],\n            index=None,\n            placeholder=\"Select your company's state\",\n            help=\"Required for accurate GST bifurcation (CGST+SGST vs IGST)\"\n        )\n    \n    # Show configuration status\n    config_status = []\n    if company_name:\n        config_status.append(f\"Company: {company_name}\")\n    if company_state:\n        config_status.append(f\"State: {company_state}\")\n    \n    if config_status:\n        st.success(f\"âœ… Configuration: {' | '.join(config_status)}\")\n    else:\n        st.info(\"ğŸ’¡ Please configure company details above to proceed\")\n    \n    st.divider()\n    \n    # Create tabs for different document types\n    tab_bank, tab_invoice, tab_gst = st.tabs([\"ğŸ¦ Bank Statements\", \"ğŸ“„ Invoices\", \"ğŸ“Š GST Returns\"])\n    \n    with tab_bank:\n        process_bank_statements(company_name)\n    \n    with tab_invoice:\n        process_invoices(company_name, company_state)\n    \n    with tab_gst:\n        process_gst_returns(company_name, company_state)\n\ndef process_bank_statements(company_name: str):\n    \"\"\"Handle bank statement processing.\"\"\"\n    st.subheader(\"ğŸ¦ Bank Statement Processing\")\n    st.markdown(\"Upload bank statement images/PDFs to extract transaction data and generate Tally XML\")\n    \n    # Bank Account Configuration\n    st.subheader(\"ğŸ’° Bank Account Configuration\")\n    bank_ledger_name = st.text_input(\n        \"Bank Ledger Name\", \n        placeholder=\"e.g., HDFC Bank, SBI Current Account\",\n        help=\"Name of the bank account ledger in your Tally (required for XML generation)\",\n        key=\"bank_ledger_input\"\n    )\n    \n    if bank_ledger_name:\n        st.success(f\"âœ… Bank Account: {bank_ledger_name}\")\n    else:\n        st.info(\"ğŸ’¡ Please enter your bank ledger name to proceed with Tally XML generation\")\n    \n    st.divider()\n    \n    # File uploader\n    uploaded_file = st.file_uploader(\n        \"Choose a bank statement file\",\n        type=['png', 'jpg', 'jpeg', 'pdf'],\n        accept_multiple_files=False,\n        help=\"Upload a clear image or PDF of your bank statement (PNG, JPG, JPEG, PDF formats supported)\",\n        key=\"bank_statement_uploader\"\n    )\n    \n    if uploaded_file is not None:\n        # Convert file to PNG format for processing\n        try:\n            png_bytes = convert_file_to_png_bytes(uploaded_file)\n            original_format = uploaded_file.name.lower().split('.')[-1].upper()\n        except Exception as e:\n            st.error(f\"Error processing file: {str(e)}\")\n            return\n        \n        # Display uploaded file\n        col1, col2 = st.columns([1, 1])\n        \n        with col1:\n            st.subheader(f\"ğŸ“„ Uploaded {original_format} File\")\n            try:\n                # Display the converted PNG image\n                display_image = Image.open(io.BytesIO(png_bytes))\n                st.image(display_image, caption=f\"Bank Statement ({original_format})\", use_column_width=True)\n                \n                # File info\n                st.info(f\"**File Details:**\\n- Original Format: {original_format}\\n- Size: {display_image.size[0]} x {display_image.size[1]} pixels\\n- Processed Format: PNG\\n- Mode: {display_image.mode}\")\n                \n            except Exception as e:\n                st.error(f\"Error displaying image: {str(e)}\")\n                return\n        \n        with col2:\n            st.subheader(\"ğŸ”„ Transaction Extraction\")\n            \n            # Check if transactions are already extracted\n            if 'extracted_transactions' in st.session_state and st.session_state.get('extraction_completed', False):\n                st.success(f\"âœ… {len(st.session_state['extracted_transactions'])} transactions already extracted!\")\n                if st.button(\"ğŸ”„ Re-extract Transactions\", type=\"secondary\"):\n                    # Clear existing data and re-extract\n                    if 'extracted_transactions' in st.session_state:\n                        del st.session_state['extracted_transactions']\n                    if 'extraction_completed' in st.session_state:\n                        del st.session_state['extraction_completed']\n                    if 'tally_xml' in st.session_state:\n                        del st.session_state['tally_xml']\n                    st.rerun()\n            else:\n                if st.button(\"Extract Transactions\", type=\"primary\"):\n                    try:\n                        # Show progress\n                        progress_bar = st.progress(0)\n                        status_text = st.empty()\n                        \n                        status_text.text(\"ğŸ” Analyzing image...\")\n                        progress_bar.progress(25)\n                        \n                        # Get extractor\n                        extractor = get_extractor()\n                        \n                        status_text.text(\"ğŸ¤– Processing with AI...\")\n                        progress_bar.progress(50)\n                        \n                        status_text.text(\"ğŸ“Š Extracting transaction data...\")\n                        progress_bar.progress(75)\n                        \n                        # Extract transactions using already converted PNG bytes\n                        transactions = extractor.extract_transactions(png_bytes)\n                        \n                        status_text.text(\"âœ… Complete!\")\n                        progress_bar.progress(100)\n                        \n                        # Store transactions in session state for persistence\n                        st.session_state['extracted_transactions'] = transactions\n                        st.session_state['extraction_completed'] = True\n                        \n                        # Clear progress indicators\n                        progress_bar.empty()\n                        status_text.empty()\n                        \n                        if transactions:\n                            st.success(f\"ğŸ‰ Successfully extracted {len(transactions)} transactions!\")\n                        else:\n                            st.warning(\"âš ï¸ No transactions found in the image. Please ensure the image is clear and contains transaction data.\")\n                            \n                    except Exception as e:\n                        st.error(f\"âŒ Error processing image: {str(e)}\")\n                        st.error(\"Please try again with a different image or check if the image is clear and readable.\")\n        \n        # Display extracted transactions if available\n        if 'extracted_transactions' in st.session_state and st.session_state.get('extraction_completed', False):\n            transactions = st.session_state['extracted_transactions']\n            \n            if transactions:\n                st.divider()\n                st.subheader(\"ğŸ“‹ Extracted Transactions\")\n                \n                # Create tabs for different views\n                tab1, tab2, tab3, tab4 = st.tabs([\"ğŸ“Š Table View\", \"ğŸ“„ JSON View\", \"ğŸ”„ Tally XML\", \"ğŸ’¾ Download\"])\n                \n                with tab1:\n                    # Display as dataframe\n                    import pandas as pd\n                    df = pd.DataFrame(transactions)\n                    st.dataframe(df, use_container_width=True)\n                            \n                    # Summary statistics\n                    if len(transactions) > 0:\n                        st.subheader(\"ğŸ“ˆ Summary\")\n                        col_a, col_b, col_c = st.columns(3)\n                        \n                        total_debits = sum(float(t.get('debit_amount', 0) or 0) for t in transactions)\n                        total_credits = sum(float(t.get('credit_amount', 0) or 0) for t in transactions)\n                        \n                        with col_a:\n                            st.metric(\"Total Transactions\", len(transactions))\n                        with col_b:\n                            st.metric(\"Total Debits\", f\"â‚¹{total_debits:,.2f}\")\n                        with col_c:\n                            st.metric(\"Total Credits\", f\"â‚¹{total_credits:,.2f}\")\n                        \n                        with tab2:\n                            # Display as JSON\n                            json_str = json.dumps(transactions, indent=2)\n                            st.code(json_str, language=\"json\")\n                        \n                        with tab3:\n                            # Tally XML Generation\n                            if company_name and bank_ledger_name:\n                                st.subheader(\"ğŸ”„ Generate Tally XML\")\n                                \n                                try:\n                                    # Initialize XML generator\n                                    xml_generator = TallyXMLGenerator(company_name, bank_ledger_name)\n                                    \n                                    # Validate data before generation\n                                    validation_result = xml_generator.validate_xml_structure(transactions)\n                                    \n                                    # Show validation results\n                                    if validation_result['valid']:\n                                        st.success(f\"âœ… Ready to generate XML for {validation_result['transaction_count']} transactions\")\n                                        \n                                        if validation_result['warnings']:\n                                            with st.expander(\"âš ï¸ Validation Warnings\"):\n                                                for warning in validation_result['warnings']:\n                                                    st.warning(warning)\n                                        \n                                        # Generate XML button\n                                        if st.button(\"ğŸ”„ Generate Tally XML\", type=\"primary\"):\n                                            with st.spinner(\"Generating Tally XML...\"):\n                                                xml_content = xml_generator.generate_xml(transactions)\n                                                \n                                                st.success(\"âœ… Tally XML generated successfully!\")\n                                                \n                                                # Display XML preview (first 2000 chars)\n                                                st.subheader(\"ğŸ“„ XML Preview\")\n                                                preview_xml = xml_content[:2000]\n                                                if len(xml_content) > 2000:\n                                                    preview_xml += \"\\n... (truncated, full XML available in download)\"\n                                                \n                                                st.code(preview_xml, language=\"xml\")\n                                                \n                                                # Store XML in session state for download\n                                                st.session_state['tally_xml'] = xml_content\n                                                \n                                                # Quick info about the XML\n                                                st.info(f\"\"\"\n                                                **XML Details:**\n                                                - Company: {company_name}\n                                                - Bank Ledger: {bank_ledger_name}\n                                                - Suspense Ledger: Suspense (auto-created if needed)\n                                                - Transactions: {len(transactions)}\n                                                - XML Size: {len(xml_content)} characters\n                                                \"\"\")\n                                    else:\n                                        st.error(\"âŒ Validation failed. Please fix the following errors:\")\n                                        for error in validation_result['errors']:\n                                            st.error(f\"â€¢ {error}\")\n                                        \n                                        if validation_result['warnings']:\n                                            st.warning(\"Additional warnings:\")\n                                            for warning in validation_result['warnings']:\n                                                st.warning(f\"â€¢ {warning}\")\n                                                \n                                except Exception as e:\n                                    st.error(f\"âŒ Error generating XML: {str(e)}\")\n                            else:\n                                st.warning(\"âš ï¸ Please configure company name and bank ledger name in the settings above to generate Tally XML\")\n                        \n                        with tab4:\n                            # Download options\n                            st.subheader(\"ğŸ’¾ Download Options\")\n                            \n                            col_dl1, col_dl2, col_dl3 = st.columns(3)\n                            \n                            with col_dl1:\n                                # JSON download\n                                json_str = json.dumps(transactions, indent=2)\n                                st.download_button(\n                                    label=\"ğŸ“„ Download JSON\",\n                                    data=json_str,\n                                    file_name=\"bank_transactions.json\",\n                                    mime=\"application/json\"\n                                )\n                            \n                            with col_dl2:\n                                # CSV download\n                                if transactions:\n                                    import pandas as pd\n                                    df = pd.DataFrame(transactions)\n                                    csv = df.to_csv(index=False)\n                                    st.download_button(\n                                        label=\"ğŸ“Š Download CSV\",\n                                        data=csv,\n                                        file_name=\"bank_transactions.csv\",\n                                        mime=\"text/csv\"\n                                    )\n                            \n                            with col_dl3:\n                                # Tally XML download\n                                if 'tally_xml' in st.session_state:\n                                    st.download_button(\n                                        label=\"ğŸ”„ Download Tally XML\",\n                                        data=st.session_state['tally_xml'],\n                                        file_name=\"tally_import.xml\",\n                                        mime=\"application/xml\"\n                                    )\n                                else:\n                                    st.info(\"Generate XML first in Tally XML tab\")\n                            \n                            # Instructions for XML import\n                            if 'tally_xml' in st.session_state:\n                                st.divider()\n                                with st.expander(\"ğŸ“– How to import XML into Tally\"):\n                                    st.markdown(\"\"\"\n                                    ### Steps to import into Tally:\n                                    \n                                    1. **Open Tally** and select your company\n                                    2. **Go to Gateway of Tally** â†’ Import â†’ XML Files\n                                    3. **Browse and select** the downloaded XML file\n                                    4. **Click Import** to process the transactions\n                                    5. **Verify** the imported transactions in your vouchers\n                                    \n                                    ### Important Notes:\n                                    - ğŸ¢ Make sure the company name matches exactly\n                                    - ğŸ’° All transactions will be posted to \"Suspense\" ledger\n                                    - âœ… The Suspense ledger will be created automatically if it doesn't exist\n                                    - ğŸ“ You can later transfer amounts from Suspense to proper ledgers\n                                    - ğŸ”„ Always backup your Tally data before importing\n                                    \n                                    ### After Import:\n                                    - Review transactions in Receipt/Payment vouchers\n                                    - Move amounts from Suspense to appropriate ledgers\n                                    - Verify running balance matches your bank statement\n                                    \"\"\")\n\n    # Instructions and tips for bank statements\n    with st.expander(\"ğŸ“– How to use Bank Statement Processing\"):\n        st.markdown(\"\"\"\n        ### Instructions:\n        1. **Upload Image**: Select a PNG image of your bank statement\n        2. **Extract Data**: Click the \"Extract Transactions\" button\n        3. **Review Results**: Check the extracted transaction data\n        4. **Download**: Save the results as JSON or CSV\n        \n        ### Tips for better results:\n        - âœ… Use high-quality, clear images\n        - âœ… Ensure good lighting and contrast\n        - âœ… Make sure all text is readable\n        - âœ… Avoid blurry or rotated images\n        - âœ… Include the complete transaction table\n        \n        ### Supported Data Fields:\n        - **Date**: Transaction date\n        - **Narration**: Transaction description\n        - **Debit Amount**: Money debited from account\n        - **Credit Amount**: Money credited to account  \n        - **Running Balance**: Account balance after transaction\n        \"\"\")\n\ndef process_invoices(company_name: str, company_state: str | None):\n    \"\"\"Handle invoice processing.\"\"\"\n    st.subheader(\"ğŸ“„ Invoice Processing\")\n    st.markdown(\"Upload invoice images to extract transaction data and generate purchase/sales vouchers\")\n    \n    if not company_name or not company_state:\n        st.warning(\"âš ï¸ Please configure company name and state in the settings above\")\n        return\n    \n    # Invoice type selection\n    invoice_type = st.selectbox(\n        \"Invoice Type\",\n        options=[\"Purchase Invoice\", \"Sales Invoice\"],\n        help=\"Select whether this is a purchase or sales invoice\"\n    )\n    \n    # File uploader for invoices\n    uploaded_file = st.file_uploader(\n        \"Choose an invoice file\",\n        type=['png', 'jpg', 'jpeg', 'pdf'],\n        help=\"Upload a clear image or PDF of your invoice\",\n        key=\"invoice_uploader\"\n    )\n    \n    if uploaded_file is not None:\n        # Convert file to PNG format for processing\n        try:\n            png_bytes = convert_file_to_png_bytes(uploaded_file)\n            original_format = uploaded_file.name.lower().split('.')[-1].upper()\n        except Exception as e:\n            st.error(f\"Error processing file: {str(e)}\")\n            return\n        \n        # Display uploaded file\n        col1, col2 = st.columns([1, 1])\n        \n        with col1:\n            st.subheader(f\"ğŸ“„ Uploaded {original_format} File\")\n            try:\n                display_image = Image.open(io.BytesIO(png_bytes))\n                st.image(display_image, caption=f\"Invoice ({original_format})\", use_column_width=True)\n                st.info(f\"**File Details:**\\n- Original Format: {original_format}\\n- Size: {display_image.size[0]} x {display_image.size[1]} pixels\")\n            except Exception as e:\n                st.error(f\"Error displaying image: {str(e)}\")\n                return\n        \n        with col2:\n            st.subheader(\"ğŸ”„ Invoice Data Extraction\")\n            \n            # Check if invoice data is already extracted\n            if f'extracted_invoice_{invoice_type}' in st.session_state and st.session_state.get(f'invoice_extraction_completed_{invoice_type}', False):\n                invoice_data = st.session_state[f'extracted_invoice_{invoice_type}']\n                st.success(f\"âœ… Invoice data already extracted!\")\n                if st.button(\"ğŸ”„ Re-extract Invoice Data\", type=\"secondary\"):\n                    # Clear existing data and re-extract\n                    if f'extracted_invoice_{invoice_type}' in st.session_state:\n                        del st.session_state[f'extracted_invoice_{invoice_type}']\n                    if f'invoice_extraction_completed_{invoice_type}' in st.session_state:\n                        del st.session_state[f'invoice_extraction_completed_{invoice_type}']\n                    if f'invoice_xml_{invoice_type}' in st.session_state:\n                        del st.session_state[f'invoice_xml_{invoice_type}']\n                    st.rerun()\n            else:\n                if st.button(\"Extract Invoice Data\", type=\"primary\"):\n                    try:\n                        # Show progress\n                        progress_bar = st.progress(0)\n                        status_text = st.empty()\n                        \n                        status_text.text(\"ğŸ” Analyzing invoice...\")\n                        progress_bar.progress(25)\n                        \n                        # Get invoice extractor\n                        @st.cache_resource\n                        def get_invoice_extractor():\n                            return InvoiceExtractor()\n                        \n                        extractor = get_invoice_extractor()\n                        \n                        status_text.text(\"ğŸ¤– Processing with AI...\")\n                        progress_bar.progress(50)\n                        \n                        # Extract invoice data\n                        invoice_data = extractor.extract_invoice_data(\n                            png_bytes, \n                            invoice_type.replace(' Invoice', '').lower(),\n                            company_state\n                        )\n                        \n                        status_text.text(\"âœ… Complete!\")\n                        progress_bar.progress(100)\n                        \n                        # Store invoice data in session state\n                        st.session_state[f'extracted_invoice_{invoice_type}'] = invoice_data\n                        st.session_state[f'invoice_extraction_completed_{invoice_type}'] = True\n                        \n                        # Clear progress indicators\n                        progress_bar.empty()\n                        status_text.empty()\n                        \n                        if invoice_data:\n                            st.success(f\"ğŸ‰ Successfully extracted invoice data!\")\n                        else:\n                            st.warning(\"âš ï¸ No invoice data found. Please ensure the image is clear and contains invoice information.\")\n                            \n                    except Exception as e:\n                        st.error(f\"âŒ Error processing invoice: {str(e)}\")\n        \n        # Display extracted invoice data if available\n        if f'extracted_invoice_{invoice_type}' in st.session_state and st.session_state.get(f'invoice_extraction_completed_{invoice_type}', False):\n            invoice_data = st.session_state[f'extracted_invoice_{invoice_type}']\n            \n            if invoice_data:\n                st.divider()\n                st.subheader(\"ğŸ“‹ Extracted Invoice Data\")\n                \n                # Create tabs for different views\n                tab1, tab2, tab3, tab4 = st.tabs([\"ğŸ“Š Invoice Details\", \"ğŸ“„ JSON View\", \"ğŸ”„ Tally XML\", \"ğŸ’¾ Download\"])\n                \n                with tab1:\n                    # Display invoice details\n                    col_info1, col_info2 = st.columns(2)\n                    \n                    with col_info1:\n                        st.markdown(\"**Invoice Information:**\")\n                        st.write(f\"Invoice Number: {invoice_data.get('invoice_number', 'N/A')}\")\n                        st.write(f\"Invoice Date: {invoice_data.get('invoice_date', 'N/A')}\")\n                        \n                        if invoice_type == \"Purchase Invoice\":\n                            st.write(f\"Vendor: {invoice_data.get('vendor_name', 'N/A')}\")\n                            st.write(f\"Vendor GSTIN: {invoice_data.get('vendor_gstin', 'N/A')}\")\n                        else:\n                            st.write(f\"Customer: {invoice_data.get('buyer_name', 'N/A')}\")\n                            st.write(f\"Customer GSTIN: {invoice_data.get('buyer_gstin', 'N/A')}\")\n                    \n                    with col_info2:\n                        st.markdown(\"**Amount Details:**\")\n                        st.write(f\"Taxable Value: â‚¹{invoice_data.get('total_taxable_value', 0):,.2f}\")\n                        st.write(f\"CGST: â‚¹{invoice_data.get('total_cgst', 0) or 0:,.2f}\")\n                        st.write(f\"SGST: â‚¹{invoice_data.get('total_sgst', 0) or 0:,.2f}\")\n                        st.write(f\"IGST: â‚¹{invoice_data.get('total_igst', 0) or 0:,.2f}\")\n                        st.write(f\"**Total: â‚¹{invoice_data.get('total_invoice_value', 0):,.2f}**\")\n                    \n                    # Display items\n                    if invoice_data.get('items'):\n                        st.subheader(\"ğŸ“¦ Line Items\")\n                        import pandas as pd\n                        items_df = pd.DataFrame(invoice_data['items'])\n                        st.dataframe(items_df, use_container_width=True)\n                \n                with tab2:\n                    # Display as JSON\n                    json_str = json.dumps(invoice_data, indent=2)\n                    st.code(json_str, language=\"json\")\n                \n                with tab3:\n                    # Tally XML Generation\n                    st.subheader(\"ğŸ”„ Generate Tally XML\")\n                    \n                    try:\n                        # Initialize XML generator\n                        xml_generator = InvoiceXMLGenerator(company_name, company_state)\n                        \n                        if st.button(\"ğŸ”„ Generate Tally XML\", type=\"primary\"):\n                            with st.spinner(\"Generating Tally XML...\"):\n                                if invoice_type == \"Purchase Invoice\":\n                                    xml_content = xml_generator.generate_purchase_xml(invoice_data)\n                                else:\n                                    xml_content = xml_generator.generate_sales_xml(invoice_data)\n                                \n                                st.success(\"âœ… Tally XML generated successfully!\")\n                                \n                                # Display XML preview (first 2000 chars)\n                                st.subheader(\"ğŸ“„ XML Preview\")\n                                preview_xml = xml_content[:2000]\n                                if len(xml_content) > 2000:\n                                    preview_xml += \"\\n... (truncated, full XML available in download)\"\n                                \n                                st.code(preview_xml, language=\"xml\")\n                                \n                                # Store XML in session state for download\n                                st.session_state[f'invoice_xml_{invoice_type}'] = xml_content\n                                \n                                # Quick info about the XML\n                                st.info(f\"\"\"\n                                **XML Details:**\n                                - Invoice Type: {invoice_type}\n                                - Company: {company_name}\n                                - Items: {len(invoice_data.get('items', []))}\n                                - XML Size: {len(xml_content)} characters\n                                \"\"\")\n                                \n                    except Exception as e:\n                        st.error(f\"âŒ Error generating XML: {str(e)}\")\n                \n                with tab4:\n                    # Download options\n                    st.subheader(\"ğŸ’¾ Download Options\")\n                    \n                    col_dl1, col_dl2, col_dl3 = st.columns(3)\n                    \n                    with col_dl1:\n                        # JSON download\n                        json_str = json.dumps(invoice_data, indent=2)\n                        st.download_button(\n                            label=\"ğŸ“„ Download JSON\",\n                            data=json_str,\n                            file_name=f\"invoice_{invoice_type.lower().replace(' ', '_')}.json\",\n                            mime=\"application/json\"\n                        )\n                    \n                    with col_dl2:\n                        # CSV download for items\n                        if invoice_data.get('items'):\n                            import pandas as pd\n                            df = pd.DataFrame(invoice_data['items'])\n                            csv = df.to_csv(index=False)\n                            st.download_button(\n                                label=\"ğŸ“Š Download Items CSV\",\n                                data=csv,\n                                file_name=f\"invoice_items_{invoice_type.lower().replace(' ', '_')}.csv\",\n                                mime=\"text/csv\"\n                            )\n                    \n                    with col_dl3:\n                        # Tally XML download\n                        if f'invoice_xml_{invoice_type}' in st.session_state:\n                            st.download_button(\n                                label=\"ğŸ”„ Download Tally XML\",\n                                data=st.session_state[f'invoice_xml_{invoice_type}'],\n                                file_name=f\"tally_{invoice_type.lower().replace(' ', '_')}.xml\",\n                                mime=\"application/xml\"\n                            )\n                        else:\n                            st.info(\"Generate XML first in Tally XML tab\")\n    \n    # Instructions\n    with st.expander(\"ğŸ“– How to use Invoice Processing\"):\n        st.markdown(\"\"\"\n        ### Instructions:\n        1. **Select Type**: Choose Purchase or Sales invoice\n        2. **Upload Image**: Select a clear image of your invoice\n        3. **Extract Data**: Click \"Extract Invoice Data\" button\n        4. **Review Results**: Check the extracted invoice details and items\n        5. **Generate XML**: Create Tally-compatible XML for import\n        6. **Download**: Save the results as JSON, CSV, or XML\n        \n        ### Features:\n        - âœ… AI-powered invoice data extraction\n        - âœ… Automatic GST calculation and bifurcation\n        - âœ… Vendor/customer master creation in XML\n        - âœ… Item-wise tax calculation\n        - âœ… Purchase/Sales voucher XML generation\n        - âœ… Descriptive ledger naming (Purchase - Item, Input CGST 18%, etc.)\n        \n        ### Tips for better results:\n        - âœ… Use high-quality, clear images\n        - âœ… Ensure all text is readable\n        - âœ… Include complete invoice with all line items\n        - âœ… Make sure GST details are visible\n        \"\"\")\n\ndef process_gst_returns(company_name: str, company_state: str | None):\n    \"\"\"Handle GST return JSON processing.\"\"\"\n    st.subheader(\"ğŸ“Š GST Return Processing\")\n    st.markdown(\"Process GST returns: Upload JSON files to generate Tally XML or create GSTR1 upload files from sales invoices\")\n    \n    if not company_name or not company_state:\n        st.warning(\"âš ï¸ Please configure company name and state in the settings above\")\n        return\n    \n    # Company GSTIN input\n    company_gstin = st.text_input(\n        \"Company GSTIN\",\n        placeholder=\"Enter your company's GSTIN (15 digits)\",\n        help=\"Required for GST portal JSON generation and processing\",\n        key=\"company_gstin_input\"\n    )\n    \n    if company_gstin and len(company_gstin) != 15:\n        st.warning(\"âš ï¸ GSTIN should be exactly 15 characters\")\n    \n    # Create tabs for different GST processing options\n    tab_upload, tab_create_gstr1, tab_gstr2b_dedicated, tab_bulk_process = st.tabs([\n        \"ğŸ“¥ Upload GST JSON to Tally\", \n        \"ğŸ“¤ Create GSTR1 from Sales Invoices\", \n        \"ğŸ›ï¸ GSTR2B Dedicated Processor\",\n        \"ğŸ”„ Bulk Process GST Data\"\n    ])\n    \n    with tab_upload:\n        st.subheader(\"ğŸ“¥ GST Portal JSON to Tally XML\")\n        st.markdown(\"Upload downloaded GST portal JSON files (GSTR1, GSTR2A, GSTR2B) to generate Tally import XML\")\n        \n        # GST return type selection\n        gst_return_type = st.selectbox(\n            \"GST Return Type\",\n            options=[\"GSTR1 (Sales)\", \"GSTR2A (Purchase)\", \"GSTR2B (Purchase)\", \"GSTR3B (Monthly Return)\"],\n            help=\"Select the type of GST return you want to process\"\n        )\n        \n        # File uploader for GST JSON\n        uploaded_gst_file = st.file_uploader(\n            \"Upload GST Return JSON File\",\n            type=['json'],\n            help=\"Upload the JSON file downloaded from GST portal\",\n            key=\"gst_json_uploader\"\n        )\n        \n        if uploaded_gst_file is not None:\n            try:\n                # Read and parse JSON\n                json_content = uploaded_gst_file.read().decode('utf-8')\n                gst_data = json.loads(json_content)\n                \n                st.success(f\"âœ… {gst_return_type} JSON file loaded successfully!\")\n                \n                # Display file info\n                st.info(f\"\"\"\n                **File Details:**\n                - File Name: {uploaded_gst_file.name}\n                - File Size: {len(json_content)} characters\n                - Return Type: {gst_return_type}\n                - GSTIN: {gst_data.get('gstin', 'Not found')}\n                - Period: {gst_data.get('ret_period', gst_data.get('fp', 'Not found'))}\n                \"\"\")\n                \n                # Generate Tally XML\n                if st.button(\"ğŸ”„ Generate Tally XML from GST Data\", type=\"primary\"):\n                    if not company_gstin:\n                        st.error(\"âŒ Please enter your company GSTIN first\")\n                    else:\n                        try:\n                            with st.spinner(\"Generating Tally XML from GST data...\"):\n                                # Initialize GST XML generator\n                                gst_xml_generator = GSTTallyXMLGenerator(company_name, company_state)\n                                \n                                # Generate XML based on return type\n                                if \"GSTR1\" in gst_return_type:\n                                    xml_content = gst_xml_generator.generate_gstr1_xml(gst_data)\n                                    xml_type = \"Sales\"\n                                elif \"GSTR2A\" in gst_return_type:\n                                    xml_content = gst_xml_generator.generate_gstr2a_xml(gst_data)\n                                    xml_type = \"Purchase\"\n                                elif \"GSTR2B\" in gst_return_type:\n                                    xml_content = gst_xml_generator.generate_gstr2b_xml(gst_data)\n                                    xml_type = \"Purchase\"\n                                else:\n                                    st.error(f\"âŒ {gst_return_type} processing not yet implemented\")\n                                    return\n                                \n                                st.success(\"âœ… Tally XML generated successfully!\")\n                                \n                                # Display XML preview\n                                st.subheader(\"ğŸ“„ XML Preview\")\n                                preview_xml = xml_content[:2000]\n                                if len(xml_content) > 2000:\n                                    preview_xml += \"\\n... (truncated, full XML available in download)\"\n                                \n                                st.code(preview_xml, language=\"xml\")\n                                \n                                # Store XML for download\n                                st.session_state['gst_tally_xml'] = xml_content\n                                \n                                # Download button\n                                st.download_button(\n                                    label=\"ğŸ’¾ Download Tally XML\",\n                                    data=xml_content,\n                                    file_name=f\"tally_{gst_return_type.lower().replace(' ', '_').replace('(', '').replace(')', '')}.xml\",\n                                    mime=\"application/xml\"\n                                )\n                                \n                        except Exception as e:\n                            st.error(f\"âŒ Error generating XML: {str(e)}\")\n                \n            except json.JSONDecodeError as e:\n                st.error(f\"âŒ Invalid JSON file: {str(e)}\")\n            except Exception as e:\n                st.error(f\"âŒ Error processing file: {str(e)}\")\n    \n    with tab_create_gstr1:\n        st.subheader(\"ğŸ“¤ Create GSTR1 JSON from Sales Invoices\")\n        st.markdown(\"Generate GST portal uploadable JSON file for GSTR1 from your processed sales invoices\")\n        \n        if not company_gstin:\n            st.warning(\"âš ï¸ Please enter your company GSTIN above first\")\n        else:\n            # Period selection\n            col_month, col_year = st.columns(2)\n            with col_month:\n                return_month = st.selectbox(\n                    \"Return Month\",\n                    options=[f\"{i:02d}\" for i in range(1, 13)],\n                    format_func=lambda x: datetime.strptime(x, \"%m\").strftime(\"%B\"),\n                    help=\"Select the month for GSTR1\"\n                )\n            \n            with col_year:\n                current_year = datetime.now().year\n                return_year = st.selectbox(\n                    \"Return Year\",\n                    options=[str(year) for year in range(current_year-2, current_year+1)],\n                    index=2,  # Default to current year\n                    help=\"Select the year for GSTR1\"\n                )\n            \n            # Check for sales invoices in session state\n            sales_invoices = []\n            if 'extracted_invoice_Sales Invoice' in st.session_state:\n                sales_invoices.append(st.session_state['extracted_invoice_Sales Invoice'])\n            \n            # File uploader for multiple sales invoices JSON\n            uploaded_sales_files = st.file_uploader(\n                \"Upload Sales Invoice JSON Files (Optional)\",\n                type=['json'],\n                accept_multiple_files=True,\n                help=\"Upload JSON files of processed sales invoices to include in GSTR1\",\n                key=\"sales_json_uploader\"\n            )\n            \n            if uploaded_sales_files:\n                try:\n                    for file in uploaded_sales_files:\n                        json_content = file.read().decode('utf-8')\n                        invoice_data = json.loads(json_content)\n                        if invoice_data.get('invoice_type') == 'sales':\n                            sales_invoices.append(invoice_data)\n                    \n                    st.success(f\"âœ… Loaded {len(uploaded_sales_files)} sales invoice files\")\n                except Exception as e:\n                    st.error(f\"âŒ Error loading sales invoice files: {str(e)}\")\n            \n            if sales_invoices:\n                st.info(f\"ğŸ“‹ Found {len(sales_invoices)} sales invoices for GSTR1 generation\")\n                \n                if st.button(\"ğŸ”„ Generate GSTR1 JSON\", type=\"primary\"):\n                    try:\n                        with st.spinner(\"Generating GSTR1 JSON...\"):\n                            # Initialize GSTR1 generator\n                            gstr1_generator = GSTPortalJSONGenerator(company_gstin, company_state)\n                            \n                            # Generate GSTR1 JSON\n                            gstr1_data = gstr1_generator.generate_gstr1_json(\n                                sales_invoices, return_month, return_year\n                            )\n                            \n                            # Validate data\n                            validation_result = gstr1_generator.validate_gstr1_data(gstr1_data)\n                            \n                            if validation_result['valid']:\n                                st.success(\"âœ… GSTR1 JSON generated successfully!\")\n                                \n                                # Display summary\n                                st.subheader(\"ğŸ“Š GSTR1 Summary\")\n                                col_sum1, col_sum2, col_sum3 = st.columns(3)\n                                \n                                with col_sum1:\n                                    st.metric(\"B2B Customers\", len(gstr1_data.get('b2b', [])))\n                                with col_sum2:\n                                    st.metric(\"B2CL Invoices\", len(gstr1_data.get('b2cl', [])))\n                                with col_sum3:\n                                    st.metric(\"B2CS Entries\", len(gstr1_data.get('b2cs', [])))\n                                \n                                # Show HSN summary\n                                hsn_data = gstr1_data.get('hsn', {}).get('data', [])\n                                if hsn_data:\n                                    st.subheader(\"ğŸ“¦ HSN Summary\")\n                                    import pandas as pd\n                                    hsn_df = pd.DataFrame(hsn_data)\n                                    st.dataframe(hsn_df, use_container_width=True)\n                                \n                                # JSON preview\n                                st.subheader(\"ğŸ“„ GSTR1 JSON Preview\")\n                                json_str = json.dumps(gstr1_data, indent=2)\n                                preview_json = json_str[:2000]\n                                if len(json_str) > 2000:\n                                    preview_json += \"\\n... (truncated, full JSON available in download)\"\n                                \n                                st.code(preview_json, language=\"json\")\n                                \n                                # Download button\n                                st.download_button(\n                                    label=\"ğŸ’¾ Download GSTR1 JSON\",\n                                    data=json_str,\n                                    file_name=f\"GSTR1_{company_gstin}_{return_month}{return_year}.json\",\n                                    mime=\"application/json\"\n                                )\n                                \n                                # Show validation warnings\n                                if validation_result['warnings']:\n                                    with st.expander(\"âš ï¸ Validation Warnings\"):\n                                        for warning in validation_result['warnings']:\n                                            st.warning(warning)\n                            \n                            else:\n                                st.error(\"âŒ GSTR1 validation failed:\")\n                                for error in validation_result['errors']:\n                                    st.error(f\"â€¢ {error}\")\n                                \n                    except Exception as e:\n                        st.error(f\"âŒ Error generating GSTR1: {str(e)}\")\n            \n            else:\n                st.info(\"ğŸ’¡ No sales invoices found. Process some sales invoices first or upload sales invoice JSON files.\")\n    \n    with tab_bulk_process:\n        st.subheader(\"ğŸ”„ Bulk Process GST Data\")\n        st.markdown(\"Advanced processing for multiple GST files and bulk operations\")\n        \n        # Placeholder for bulk processing features\n        st.info(\"ğŸ”® Advanced bulk processing features coming soon:\")\n        st.markdown(\"\"\"\n        **Planned Features:**\n        - ğŸ“ Bulk upload multiple GST return files\n        - ğŸ”„ Batch conversion to Tally XML\n        - ğŸ“Š Consolidated GST analysis and reports\n        - ğŸ” Data validation and error checking\n        - ğŸ“ˆ GST compliance reports\n        - ğŸ’¾ Bulk download processed files\n        \"\"\")\n    \n    # Instructions\n    with st.expander(\"ğŸ“– How to use GST Return Processing\"):\n        st.markdown(\"\"\"\n        ### ğŸ“¥ Upload GST JSON to Tally:\n        1. **Download** your GST return JSON from GST portal\n        2. **Select** the appropriate return type (GSTR1, GSTR2A, GSTR2B)\n        3. **Upload** the JSON file\n        4. **Generate** Tally XML for direct import\n        \n        ### ğŸ“¤ Create GSTR1 from Sales Invoices:\n        1. **Enter** your company GSTIN and select return period\n        2. **Upload** processed sales invoice JSON files\n        3. **Generate** GSTR1 JSON for portal upload\n        4. **Validate** and download the file\n        \n        ### Features:\n        - âœ… Convert GST portal JSON to Tally XML\n        - âœ… Generate GSTR1 from sales invoices\n        - âœ… Automatic GST bifurcation (CGST+SGST vs IGST)\n        - âœ… Smart party and ledger creation\n        - âœ… Data validation and error checking\n        - âœ… HSN-wise summary for GSTR1\n        - âœ… B2B, B2CL, B2CS categorization\n        \n        ### Supported Formats:\n        - **Input**: GST portal JSON files, Sales invoice JSON\n        - **Output**: Tally XML, GSTR1 JSON for portal upload\n        \"\"\")\n    \n    # GST Portal Offline JSON Generator\n    st.divider()\n    st.markdown(\"### ğŸ”§ GST Portal Offline Utility\")\n    st.markdown(\"Create JSON files for uploading to GST portal (offline utility tool)\")\n    \n    with st.expander(\"ğŸ“¤ Generate GSTR1 JSON for GST Portal Upload\"):\n        st.markdown(\"**Create GSTR1 JSON file for outward supplies to upload on GST portal**\")\n        \n        # Invoice entry form\n        st.subheader(\"Invoice Details Entry\")\n        col1, col2 = st.columns(2)\n        \n        with col1:\n            customer_gstin = st.text_input(\"Customer GSTIN\", placeholder=\"01ABCDE1234F1Z5\")\n            invoice_number = st.text_input(\"Invoice Number\", placeholder=\"INV001\")\n            invoice_date = st.date_input(\"Invoice Date\")\n        \n        with col2:\n            place_of_supply = st.selectbox(\"Place of Supply\", \n                options=[\"01-Jammu and Kashmir\", \"02-Himachal Pradesh\", \"03-Punjab\", \"04-Chandigarh\", \n                        \"05-Uttarakhand\", \"06-Haryana\", \"07-Delhi\", \"08-Rajasthan\", \"09-Uttar Pradesh\",\n                        \"10-Bihar\", \"11-Sikkim\", \"12-Arunachal Pradesh\", \"13-Nagaland\", \"14-Manipur\",\n                        \"15-Mizoram\", \"16-Tripura\", \"17-Meghalaya\", \"18-Assam\", \"19-West Bengal\",\n                        \"20-Jharkhand\", \"21-Odisha\", \"22-Chhattisgarh\", \"23-Madhya Pradesh\",\n                        \"24-Gujarat\", \"25-Daman and Diu\", \"26-Dadra and Nagar Haveli\", \"27-Maharashtra\",\n                        \"28-Andhra Pradesh\", \"29-Karnataka\", \"30-Goa\", \"31-Lakshadweep\", \"32-Kerala\",\n                        \"33-Tamil Nadu\", \"34-Puducherry\", \"35-Andaman and Nicobar Islands\", \"36-Telangana\",\n                        \"37-Andhra Pradesh\"],\n                help=\"Select place of supply for the transaction\")\n            \n            tax_rate = st.selectbox(\"Tax Rate (%)\", options=[0, 5, 12, 18, 28])\n            taxable_value = st.number_input(\"Taxable Value (â‚¹)\", min_value=0.0, format=\"%.2f\")\n        \n        if st.button(\"Add to GSTR1 JSON\", type=\"primary\"):\n            if customer_gstin and invoice_number and taxable_value > 0:\n                # Create GSTR1 JSON structure\n                pos_code = place_of_supply.split('-')[0]\n                gst_processor = GSTProcessor(company_state)\n                company_state_code = next((code for state, code in gst_processor.state_codes.items() if state == company_state), \"27\")\n                \n                # Calculate tax amounts\n                is_interstate = pos_code != company_state_code\n                if is_interstate:\n                    igst_amount = (taxable_value * tax_rate) / 100\n                    cgst_amount = 0\n                    sgst_amount = 0\n                else:\n                    igst_amount = 0\n                    cgst_amount = (taxable_value * tax_rate) / 200  # Half of total tax\n                    sgst_amount = (taxable_value * tax_rate) / 200  # Half of total tax\n                \n                total_value = taxable_value + igst_amount + cgst_amount + sgst_amount\n                \n                gstr1_json = {\n                    \"version\": \"GST1.1\",\n                    \"hash\": \"auto_generated_hash\",\n                    \"gstin\": f\"{company_state_code}ABCDE1234F1Z5\",  # Placeholder GSTIN\n                    \"fp\": invoice_date.strftime(\"%m%Y\"),\n                    \"b2b\": [\n                        {\n                            \"ctin\": customer_gstin,\n                            \"inv\": [\n                                {\n                                    \"inum\": invoice_number,\n                                    \"idt\": invoice_date.strftime(\"%d-%m-%Y\"),\n                                    \"val\": round(total_value, 2),\n                                    \"pos\": pos_code,\n                                    \"rchrg\": \"N\",\n                                    \"etin\": \"\",\n                                    \"inv_typ\": \"R\",\n                                    \"itms\": [\n                                        {\n                                            \"num\": 1,\n                                            \"itm_det\": {\n                                                \"rt\": tax_rate,\n                                                \"txval\": round(taxable_value, 2),\n                                                \"iamt\": round(igst_amount, 2),\n                                                \"camt\": round(cgst_amount, 2),\n                                                \"samt\": round(sgst_amount, 2),\n                                                \"csamt\": 0\n                                            }\n                                        }\n                                    ]\n                                }\n                            ]\n                        }\n                    ],\n                    \"b2cs\": [],\n                    \"hsn\": [],\n                    \"doc_issue\": {}\n                }\n                \n                st.success(\"âœ… GSTR1 JSON created successfully!\")\n                \n                # Display JSON preview\n                st.subheader(\"ğŸ“„ Generated JSON Preview\")\n                st.code(json.dumps(gstr1_json, indent=2), language=\"json\")\n                \n                # Download button\n                json_str = json.dumps(gstr1_json, indent=2)\n                st.download_button(\n                    label=\"ğŸ“¥ Download GSTR1 JSON for GST Portal\",\n                    data=json_str,\n                    file_name=f\"GSTR1_{invoice_date.strftime('%m%Y')}_{invoice_number}.json\",\n                    mime=\"application/json\"\n                )\n                \n                st.info(\"\"\"\n                **How to use this JSON file:**\n                1. Download the JSON file\n                2. Login to GST Portal â†’ Returns Dashboard\n                3. Select GSTR-1 â†’ Upload JSON File\n                4. Browse and select this downloaded file\n                5. Review and submit your return\n                \"\"\")\n            else:\n                st.error(\"âš ï¸ Please fill all required fields with valid data\")\n    \n    # Instructions\n    with st.expander(\"ğŸ“– How to use GST Return Processing\"):\n        st.markdown(\"\"\"\n        ### Features:\n        - âš¡ **Ultra-fast processing**: JSON parsing in milliseconds\n        - ğŸ“Š **Bulk transactions**: Process hundreds of transactions at once\n        - ğŸ§  **Smart ledger naming**: \"Input IGST 18%\", \"Local Purchase 28%\"\n        - ğŸ¢ **Auto party creation**: Extract vendor/customer from GSTIN\n        - ğŸ—ºï¸ **State-based logic**: Automatic CGST+SGST vs IGST determination\n        \n        ### How to use:\n        1. Download JSON files from GST portal (GSTR2B/1/2A)\n        2. Select the correct return type above\n        3. Upload the JSON files\n        4. Review the extracted transactions and ledger names\n        5. XML generation coming soon!\n        \n        ### Supported Returns:\n        - **GSTR2B**: Purchase transactions with input tax credit\n        - **GSTR1**: Sales transactions with output tax\n        - **GSTR2A**: Purchase transactions (auto-matched)\n        \"\"\")\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":56811},"gst_portal_json_generator.py":{"content":"import json\nfrom typing import List, Dict, Any, Optional\nfrom datetime import datetime\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass GSTPortalJSONGenerator:\n    \"\"\"Generate GST portal compatible JSON files for offline filing.\"\"\"\n    \n    def __init__(self, company_gstin: str, company_state: str):\n        \"\"\"\n        Initialize GST portal JSON generator.\n        \n        Args:\n            company_gstin: Company's GSTIN\n            company_state: Company's state\n        \"\"\"\n        self.company_gstin = company_gstin\n        self.company_state = company_state\n        \n        # State code mapping\n        self.state_codes = {\n            \"Andhra Pradesh\": \"37\", \"Arunachal Pradesh\": \"12\", \"Assam\": \"18\", \"Bihar\": \"10\",\n            \"Chhattisgarh\": \"22\", \"Goa\": \"30\", \"Gujarat\": \"24\", \"Haryana\": \"06\", \n            \"Himachal Pradesh\": \"02\", \"Jharkhand\": \"20\", \"Karnataka\": \"29\", \"Kerala\": \"32\",\n            \"Madhya Pradesh\": \"23\", \"Maharashtra\": \"27\", \"Manipur\": \"14\", \"Meghalaya\": \"17\",\n            \"Mizoram\": \"15\", \"Nagaland\": \"13\", \"Odisha\": \"21\", \"Punjab\": \"03\", \"Rajasthan\": \"08\",\n            \"Sikkim\": \"11\", \"Tamil Nadu\": \"33\", \"Telangana\": \"36\", \"Tripura\": \"16\",\n            \"Uttar Pradesh\": \"09\", \"Uttarakhand\": \"05\", \"West Bengal\": \"19\", \"Delhi\": \"07\",\n            \"Puducherry\": \"34\"\n        }\n    \n    def generate_gstr1_json(self, sales_invoices: List[Dict[str, Any]], month: str, year: str) -> Dict[str, Any]:\n        \"\"\"\n        Generate GSTR1 JSON for sales invoices.\n        \n        Args:\n            sales_invoices: List of sales invoice data\n            month: Month (MM format)\n            year: Year (YYYY format)\n            \n        Returns:\n            GSTR1 JSON structure\n        \"\"\"\n        try:\n            # Initialize GSTR1 structure\n            gstr1_data = {\n                \"gstin\": self.company_gstin,\n                \"ret_period\": f\"{month}{year}\",\n                \"version\": \"GST3.0.4\",\n                \"hash\": \"hash\",\n                \"b2b\": [],\n                \"b2cl\": [],\n                \"b2cs\": [],\n                \"hsn\": {},\n                \"doc_issue\": []\n            }\n            \n            # Process each invoice\n            for invoice in sales_invoices:\n                buyer_gstin = invoice.get('buyer_gstin', '').strip()\n                total_value = float(invoice.get('total_invoice_value', 0))\n                buyer_state = invoice.get('buyer_state', '').strip()\n                \n                # Determine invoice category\n                if buyer_gstin and len(buyer_gstin) == 15:\n                    # B2B - Business to Business (with GSTIN)\n                    self._add_b2b_invoice(gstr1_data, invoice)\n                elif total_value > 250000 and not buyer_gstin:\n                    # B2CL - Business to Consumer Large (>2.5L without GSTIN)\n                    self._add_b2cl_invoice(gstr1_data, invoice)\n                else:\n                    # B2CS - Business to Consumer Small (<=2.5L without GSTIN)\n                    self._add_b2cs_invoice(gstr1_data, invoice)\n                \n                # Add HSN summary\n                self._add_hsn_summary(gstr1_data, invoice)\n            \n            # Process HSN summary\n            gstr1_data[\"hsn\"] = self._process_hsn_summary(gstr1_data[\"hsn\"])\n            \n            return gstr1_data\n            \n        except Exception as e:\n            logger.error(f\"Error generating GSTR1 JSON: {e}\")\n            return {}\n    \n    def _add_b2b_invoice(self, gstr1_data: Dict[str, Any], invoice: Dict[str, Any]):\n        \"\"\"Add B2B invoice to GSTR1.\"\"\"\n        buyer_gstin = invoice.get('buyer_gstin', '').strip()\n        \n        # Find existing GSTIN entry or create new\n        gstin_entry = None\n        for entry in gstr1_data[\"b2b\"]:\n            if entry[\"ctin\"] == buyer_gstin:\n                gstin_entry = entry\n                break\n        \n        if not gstin_entry:\n            gstin_entry = {\n                \"ctin\": buyer_gstin,\n                \"inv\": []\n            }\n            gstr1_data[\"b2b\"].append(gstin_entry)\n        \n        # Create invoice entry\n        invoice_entry = {\n            \"inum\": invoice.get('invoice_number', ''),\n            \"idt\": self._format_date_for_gst(invoice.get('invoice_date', '')),\n            \"val\": float(invoice.get('total_invoice_value', 0)),\n            \"pos\": self._get_state_code(invoice.get('buyer_state', '')),\n            \"rchrg\": \"N\",\n            \"inv_typ\": \"R\",\n            \"itms\": []\n        }\n        \n        # Add items\n        for item in invoice.get('items', []):\n            item_entry = {\n                \"num\": len(invoice_entry[\"itms\"]) + 1,\n                \"itm_det\": {\n                    \"hsn_sc\": item.get('hsn_code', ''),\n                    \"txval\": float(item.get('taxable_value', 0)),\n                    \"rt\": float(item.get('igst_rate', 0)) if item.get('igst_amount', 0) > 0 else float(item.get('cgst_rate', 0)) * 2,\n                    \"iamt\": float(item.get('igst_amount', 0)),\n                    \"camt\": float(item.get('cgst_amount', 0)),\n                    \"samt\": float(item.get('sgst_amount', 0)),\n                    \"csamt\": 0\n                }\n            }\n            invoice_entry[\"itms\"].append(item_entry)\n        \n        gstin_entry[\"inv\"].append(invoice_entry)\n    \n    def _add_b2cl_invoice(self, gstr1_data: Dict[str, Any], invoice: Dict[str, Any]):\n        \"\"\"Add B2CL invoice to GSTR1.\"\"\"\n        invoice_entry = {\n            \"inum\": invoice.get('invoice_number', ''),\n            \"idt\": self._format_date_for_gst(invoice.get('invoice_date', '')),\n            \"val\": float(invoice.get('total_invoice_value', 0)),\n            \"pos\": self._get_state_code(invoice.get('buyer_state', '')),\n            \"itms\": []\n        }\n        \n        # Add items\n        for item in invoice.get('items', []):\n            item_entry = {\n                \"num\": len(invoice_entry[\"itms\"]) + 1,\n                \"itm_det\": {\n                    \"hsn_sc\": item.get('hsn_code', ''),\n                    \"txval\": float(item.get('taxable_value', 0)),\n                    \"rt\": float(item.get('igst_rate', 0)) if item.get('igst_amount', 0) > 0 else float(item.get('cgst_rate', 0)) * 2,\n                    \"iamt\": float(item.get('igst_amount', 0)),\n                    \"camt\": float(item.get('cgst_amount', 0)),\n                    \"samt\": float(item.get('sgst_amount', 0)),\n                    \"csamt\": 0\n                }\n            }\n            invoice_entry[\"itms\"].append(item_entry)\n        \n        gstr1_data[\"b2cl\"].append(invoice_entry)\n    \n    def _add_b2cs_invoice(self, gstr1_data: Dict[str, Any], invoice: Dict[str, Any]):\n        \"\"\"Add B2CS invoice to GSTR1.\"\"\"\n        # B2CS is summarized by HSN, rate, and place of supply\n        for item in invoice.get('items', []):\n            pos = self._get_state_code(invoice.get('buyer_state', ''))\n            hsn_code = item.get('hsn_code', '')\n            rate = float(item.get('igst_rate', 0)) if item.get('igst_amount', 0) > 0 else float(item.get('cgst_rate', 0)) * 2\n            \n            # Find existing entry or create new\n            entry_key = f\"{hsn_code}_{rate}_{pos}\"\n            entry_found = False\n            \n            for entry in gstr1_data[\"b2cs\"]:\n                if (entry.get(\"hsn_sc\") == hsn_code and \n                    entry.get(\"rt\") == rate and \n                    entry.get(\"pos\") == pos):\n                    # Add to existing entry\n                    entry[\"txval\"] += float(item.get('taxable_value', 0))\n                    entry[\"iamt\"] += float(item.get('igst_amount', 0))\n                    entry[\"camt\"] += float(item.get('cgst_amount', 0))\n                    entry[\"samt\"] += float(item.get('sgst_amount', 0))\n                    entry_found = True\n                    break\n            \n            if not entry_found:\n                new_entry = {\n                    \"hsn_sc\": hsn_code,\n                    \"txval\": float(item.get('taxable_value', 0)),\n                    \"rt\": rate,\n                    \"iamt\": float(item.get('igst_amount', 0)),\n                    \"camt\": float(item.get('cgst_amount', 0)),\n                    \"samt\": float(item.get('sgst_amount', 0)),\n                    \"csamt\": 0,\n                    \"pos\": pos,\n                    \"typ\": \"OE\"\n                }\n                gstr1_data[\"b2cs\"].append(new_entry)\n    \n    def _add_hsn_summary(self, gstr1_data: Dict[str, Any], invoice: Dict[str, Any]):\n        \"\"\"Add HSN summary data.\"\"\"\n        if \"hsn\" not in gstr1_data:\n            gstr1_data[\"hsn\"] = {}\n        \n        for item in invoice.get('items', []):\n            hsn_code = item.get('hsn_code', '')\n            if not hsn_code:\n                continue\n            \n            if hsn_code not in gstr1_data[\"hsn\"]:\n                gstr1_data[\"hsn\"][hsn_code] = {\n                    \"hsn_sc\": hsn_code,\n                    \"desc\": item.get('description', ''),\n                    \"uqc\": item.get('unit', 'NOS'),\n                    \"qty\": 0,\n                    \"val\": 0,\n                    \"txval\": 0,\n                    \"iamt\": 0,\n                    \"camt\": 0,\n                    \"samt\": 0,\n                    \"csamt\": 0\n                }\n            \n            # Accumulate values\n            hsn_entry = gstr1_data[\"hsn\"][hsn_code]\n            hsn_entry[\"qty\"] += float(item.get('quantity', 0))\n            hsn_entry[\"val\"] += float(item.get('total_amount', 0))\n            hsn_entry[\"txval\"] += float(item.get('taxable_value', 0))\n            hsn_entry[\"iamt\"] += float(item.get('igst_amount', 0))\n            hsn_entry[\"camt\"] += float(item.get('cgst_amount', 0))\n            hsn_entry[\"samt\"] += float(item.get('sgst_amount', 0))\n    \n    def _process_hsn_summary(self, hsn_dict: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Process HSN summary into final format.\"\"\"\n        if not hsn_dict:\n            return {\"data\": []}\n        \n        hsn_list = []\n        for hsn_code, hsn_data in hsn_dict.items():\n            hsn_list.append({\n                \"num\": len(hsn_list) + 1,\n                \"hsn_sc\": hsn_data[\"hsn_sc\"],\n                \"desc\": hsn_data[\"desc\"][:30],  # Limit description length\n                \"uqc\": hsn_data[\"uqc\"],\n                \"qty\": round(hsn_data[\"qty\"], 2),\n                \"val\": round(hsn_data[\"val\"], 2),\n                \"txval\": round(hsn_data[\"txval\"], 2),\n                \"iamt\": round(hsn_data[\"iamt\"], 2),\n                \"camt\": round(hsn_data[\"camt\"], 2),\n                \"samt\": round(hsn_data[\"samt\"], 2),\n                \"csamt\": round(hsn_data[\"csamt\"], 2)\n            })\n        \n        return {\"data\": hsn_list}\n    \n    def _get_state_code(self, state_name: str) -> str:\n        \"\"\"Get state code for GST portal.\"\"\"\n        if not state_name:\n            return self.state_codes.get(self.company_state, \"01\")\n        \n        # Clean state name\n        clean_state = state_name.strip().title()\n        return self.state_codes.get(clean_state, \"01\")\n    \n    def _format_date_for_gst(self, date_str: str) -> str:\n        \"\"\"Format date for GST portal (DD-MM-YYYY).\"\"\"\n        if not date_str:\n            return datetime.now().strftime(\"%d-%m-%Y\")\n        \n        try:\n            # Try common date formats\n            for fmt in [\"%Y-%m-%d\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%Y/%m/%d\", \"%d.%m.%Y\"]:\n                try:\n                    dt = datetime.strptime(date_str, fmt)\n                    return dt.strftime(\"%d-%m-%Y\")\n                except ValueError:\n                    continue\n            \n            logger.warning(f\"Could not parse date: {date_str}, using current date\")\n            return datetime.now().strftime(\"%d-%m-%Y\")\n            \n        except Exception as e:\n            logger.error(f\"Error formatting date {date_str}: {e}\")\n            return datetime.now().strftime(\"%d-%m-%Y\")\n    \n    def validate_gstr1_data(self, gstr1_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Validate GSTR1 data before generation.\"\"\"\n        validation_result = {\n            'valid': True,\n            'errors': [],\n            'warnings': []\n        }\n        \n        # Check required fields\n        if not gstr1_data.get('gstin'):\n            validation_result['valid'] = False\n            validation_result['errors'].append(\"GSTIN is required\")\n        \n        if not gstr1_data.get('ret_period'):\n            validation_result['valid'] = False\n            validation_result['errors'].append(\"Return period is required\")\n        \n        # Validate invoice data\n        total_invoices = len(gstr1_data.get('b2b', [])) + len(gstr1_data.get('b2cl', [])) + len(gstr1_data.get('b2cs', []))\n        if total_invoices == 0:\n            validation_result['warnings'].append(\"No invoices found in the return\")\n        \n        # Validate HSN data\n        hsn_data = gstr1_data.get('hsn', {}).get('data', [])\n        if not hsn_data:\n            validation_result['warnings'].append(\"No HSN summary data found\")\n        \n        return validation_result","size_bytes":12992},"gst_processor.py":{"content":"import json\nimport logging\nfrom typing import List, Dict, Any, Optional\nfrom datetime import datetime\nfrom dataclasses import dataclass\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass GSTTransaction:\n    \"\"\"Represents a GST transaction from return data.\"\"\"\n    date: str\n    party_name: str\n    party_gstin: str\n    party_state: str\n    invoice_number: str\n    invoice_date: str\n    taxable_value: float\n    igst_amount: float\n    cgst_amount: float\n    sgst_amount: float\n    total_tax: float\n    invoice_value: float\n    is_interstate: bool\n    transaction_type: str  # 'purchase' or 'sales'\n\nclass GSTProcessor:\n    \"\"\"Process GST return JSON files to extract transaction data.\"\"\"\n    \n    def __init__(self, company_state: str):\n        \"\"\"\n        Initialize GST processor.\n        \n        Args:\n            company_state: State of the company for interstate determination\n        \"\"\"\n        self.company_state = company_state\n        \n        # State code mapping for GST bifurcation\n        self.state_codes = {\n            \"Andhra Pradesh\": \"37\", \"Arunachal Pradesh\": \"12\", \"Assam\": \"18\", \"Bihar\": \"10\",\n            \"Chhattisgarh\": \"22\", \"Goa\": \"30\", \"Gujarat\": \"24\", \"Haryana\": \"06\", \n            \"Himachal Pradesh\": \"02\", \"Jharkhand\": \"20\", \"Karnataka\": \"29\", \"Kerala\": \"32\",\n            \"Madhya Pradesh\": \"23\", \"Maharashtra\": \"27\", \"Manipur\": \"14\", \"Meghalaya\": \"17\",\n            \"Mizoram\": \"15\", \"Nagaland\": \"13\", \"Odisha\": \"21\", \"Punjab\": \"03\", \"Rajasthan\": \"08\",\n            \"Sikkim\": \"11\", \"Tamil Nadu\": \"33\", \"Telangana\": \"36\", \"Tripura\": \"16\",\n            \"Uttar Pradesh\": \"09\", \"Uttarakhand\": \"05\", \"West Bengal\": \"19\", \"Delhi\": \"07\",\n            \"Puducherry\": \"34\"\n        }\n    \n    def process_gstr2b(self, json_data: Dict[str, Any]) -> List[GSTTransaction]:\n        \"\"\"\n        Process GSTR2B JSON data to extract purchase transactions.\n        GSTR2B has Parts A, B, C, D structure from GST portal.\n        \n        Args:\n            json_data: GSTR2B JSON data from GST portal\n            \n        Returns:\n            List of GST transactions\n        \"\"\"\n        transactions = []\n        \n        try:\n            logger.info(\"Processing GSTR2B - Static ITC statement\")\n            \n            # GSTR2B has different structure with Parts A, B, C, D\n            # Part A: ITC Available - Inward supplies from registered suppliers\n            if 'itc_avl' in json_data:\n                part_a = json_data['itc_avl']\n                \n                # Process B2B invoices in Part A\n                if 'b2b' in part_a:\n                    for supplier_data in part_a['b2b']:\n                        supplier_gstin = supplier_data.get('gstin', '')\n                        supplier_state = self._get_state_from_gstin(supplier_gstin)\n                        \n                        for invoice in supplier_data.get('inv', []):\n                            transaction = self._process_gstr2b_b2b_invoice(\n                                invoice, supplier_gstin, supplier_state\n                            )\n                            if transaction:\n                                transactions.append(transaction)\n                \n                # Process Import data in Part A\n                if 'impg' in part_a:\n                    for import_data in part_a['impg']:\n                        transaction = self._process_gstr2b_import_transaction(import_data)\n                        if transaction:\n                            transactions.append(transaction)\n            \n            # Part B: ISD Credits Received\n            if 'isd_credit' in json_data:\n                for isd_data in json_data['isd_credit']:\n                    transaction = self._process_gstr2b_isd_transaction(isd_data)\n                    if transaction:\n                        transactions.append(transaction)\n            \n            logger.info(f\"Processed GSTR2B: {len(transactions)} purchase transactions\")\n            return transactions\n            \n        except Exception as e:\n            logger.error(f\"Error processing GSTR2B: {e}\")\n            return []\n    \n    def process_gstr1(self, json_data: Dict[str, Any]) -> List[GSTTransaction]:\n        \"\"\"\n        Process GSTR1 JSON data to extract sales transactions.\n        Based on actual GST portal format: {\"version\": \"GST1.1\", \"gstin\": \"...\", \"fp\": \"...\", \"b2b\": [], \"b2cs\": [], \"hsn\": []}\n        \n        Args:\n            json_data: GSTR1 JSON data from GST portal\n            \n        Returns:\n            List of GST transactions\n        \"\"\"\n        transactions = []\n        \n        try:\n            # GSTR1 has direct structure with b2b, b2cs, hsn at root level\n            logger.info(f\"Processing GSTR1 with version: {json_data.get('version', 'Unknown')}\")\n            \n            # Process B2B sales (Business to Business)\n            if 'b2b' in json_data:\n                for customer_data in json_data['b2b']:\n                    customer_gstin = customer_data.get('ctin', '')\n                    customer_state = self._get_state_from_gstin(customer_gstin)\n                    \n                    for invoice in customer_data.get('inv', []):\n                        transaction = self._process_gstr1_b2b_invoice(\n                            invoice, customer_gstin, customer_state\n                        )\n                        if transaction:\n                            transactions.append(transaction)\n            \n            # Process B2CS sales (Business to Consumer - Small)\n            if 'b2cs' in json_data:\n                for b2cs_data in json_data['b2cs']:\n                    transaction = self._process_gstr1_b2cs_transaction(b2cs_data)\n                    if transaction:\n                        transactions.append(transaction)\n            \n            logger.info(f\"Processed GSTR1: {len(transactions)} sales transactions\")\n            return transactions\n            \n        except Exception as e:\n            logger.error(f\"Error processing GSTR1: {e}\")\n            return []\n    \n    def process_gstr2a(self, json_data: Dict[str, Any]) -> List[GSTTransaction]:\n        \"\"\"\n        Process GSTR2A JSON data to extract purchase transactions.\n        GSTR2A is auto-generated and similar to GSTR2B but with different structure.\n        \n        Args:\n            json_data: GSTR2A JSON data from GST portal\n            \n        Returns:\n            List of GST transactions\n        \"\"\"\n        transactions = []\n        \n        try:\n            logger.info(\"Processing GSTR2A - Auto-drafted inward supplies\")\n            \n            # GSTR2A typically has b2b, b2ba (amendments), cdnr (credit/debit notes) sections\n            # Process B2B invoices\n            if 'b2b' in json_data:\n                for supplier_data in json_data['b2b']:\n                    supplier_gstin = supplier_data.get('ctin', '')\n                    supplier_state = self._get_state_from_gstin(supplier_gstin)\n                    \n                    for invoice in supplier_data.get('inv', []):\n                        transaction = self._process_gstr2a_b2b_invoice(\n                            invoice, supplier_gstin, supplier_state\n                        )\n                        if transaction:\n                            transactions.append(transaction)\n            \n            # Process Import data\n            if 'impg' in json_data:\n                for import_data in json_data['impg']:\n                    transaction = self._process_gstr2a_import_transaction(import_data)\n                    if transaction:\n                        transactions.append(transaction)\n            \n            logger.info(f\"Processed GSTR2A: {len(transactions)} purchase transactions\")\n            return transactions\n            \n        except Exception as e:\n            logger.error(f\"Error processing GSTR2A: {e}\")\n            return []\n\n    def _process_gstr1_b2b_invoice(self, invoice: Dict[str, Any], customer_gstin: str, \n                                 customer_state: str) -> Optional[GSTTransaction]:\n        \"\"\"Process a B2B invoice from GSTR1 format.\"\"\"\n        try:\n            invoice_number = invoice.get('inum', '')\n            invoice_date = invoice.get('idt', '')\n            invoice_value = float(invoice.get('val', 0))\n            pos = invoice.get('pos', '')  # Place of supply\n            \n            # Process items with correct GSTR1 structure\n            total_taxable = 0\n            total_igst = 0\n            total_cgst = 0\n            total_sgst = 0\n            \n            for item in invoice.get('itms', []):\n                # GSTR1 has itm_det directly under itms\n                itm_det = item.get('itm_det', {})\n                total_taxable += float(itm_det.get('txval', 0))\n                total_igst += float(itm_det.get('iamt', 0))\n                total_cgst += float(itm_det.get('camt', 0))\n                total_sgst += float(itm_det.get('samt', 0))\n            \n            total_tax = total_igst + total_cgst + total_sgst\n            is_interstate = total_igst > 0 or customer_state != self.company_state\n            \n            party_name = f\"Customer-{customer_gstin[:10]}\" if customer_gstin else \"Unknown Customer\"\n            \n            return GSTTransaction(\n                date=self._format_date(invoice_date),\n                party_name=party_name,\n                party_gstin=customer_gstin,\n                party_state=customer_state,\n                invoice_number=invoice_number,\n                invoice_date=invoice_date,\n                taxable_value=total_taxable,\n                igst_amount=total_igst,\n                cgst_amount=total_cgst,\n                sgst_amount=total_sgst,\n                total_tax=total_tax,\n                invoice_value=invoice_value,\n                is_interstate=is_interstate,\n                transaction_type='sales'\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error processing GSTR1 B2B invoice: {e}\")\n            return None\n\n    def _process_gstr1_b2cs_transaction(self, b2cs_data: Dict[str, Any]) -> Optional[GSTTransaction]:\n        \"\"\"Process B2CS transaction from GSTR1 format.\"\"\"\n        try:\n            supply_type = b2cs_data.get('sply_ty', '')  # INTER/INTRA\n            pos = b2cs_data.get('pos', '')  # Place of supply\n            typ = b2cs_data.get('typ', '')  # OE/E\n            rate = float(b2cs_data.get('rt', 0))\n            \n            total_taxable = float(b2cs_data.get('txval', 0))\n            total_igst = float(b2cs_data.get('iamt', 0))\n            total_cgst = float(b2cs_data.get('camt', 0))\n            total_sgst = float(b2cs_data.get('samt', 0))\n            \n            total_tax = total_igst + total_cgst + total_sgst\n            total_value = total_taxable + total_tax\n            is_interstate = supply_type == 'INTER' or total_igst > 0\n            \n            return GSTTransaction(\n                date=datetime.now().strftime(\"%Y-%m-%d\"),\n                party_name=f\"B2CS-{supply_type}-{pos}\",\n                party_gstin=\"\",\n                party_state=pos,\n                invoice_number=f\"B2CS-{supply_type}-Consolidated\",\n                invoice_date=\"\",\n                taxable_value=total_taxable,\n                igst_amount=total_igst,\n                cgst_amount=total_cgst,\n                sgst_amount=total_sgst,\n                total_tax=total_tax,\n                invoice_value=total_value,\n                is_interstate=is_interstate,\n                transaction_type='sales'\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error processing GSTR1 B2CS transaction: {e}\")\n            return None\n\n    def _process_gstr2b_b2b_invoice(self, invoice: Dict[str, Any], supplier_gstin: str, \n                                  supplier_state: str) -> Optional[GSTTransaction]:\n        \"\"\"Process a B2B invoice from GSTR2B format.\"\"\"\n        try:\n            invoice_number = invoice.get('inum', '')\n            invoice_date = invoice.get('idt', '')\n            invoice_value = float(invoice.get('val', 0))\n            \n            # GSTR2B structure for items\n            total_taxable = 0\n            total_igst = 0\n            total_cgst = 0\n            total_sgst = 0\n            \n            for item in invoice.get('items', []):\n                total_taxable += float(item.get('txval', 0))\n                total_igst += float(item.get('iamt', 0))\n                total_cgst += float(item.get('camt', 0))\n                total_sgst += float(item.get('samt', 0))\n            \n            total_tax = total_igst + total_cgst + total_sgst\n            is_interstate = total_igst > 0 or supplier_state != self.company_state\n            \n            party_name = f\"Supplier-{supplier_gstin[:10]}\" if supplier_gstin else \"Unknown Supplier\"\n            \n            return GSTTransaction(\n                date=self._format_date(invoice_date),\n                party_name=party_name,\n                party_gstin=supplier_gstin,\n                party_state=supplier_state,\n                invoice_number=invoice_number,\n                invoice_date=invoice_date,\n                taxable_value=total_taxable,\n                igst_amount=total_igst,\n                cgst_amount=total_cgst,\n                sgst_amount=total_sgst,\n                total_tax=total_tax,\n                invoice_value=invoice_value,\n                is_interstate=is_interstate,\n                transaction_type='purchase'\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error processing GSTR2B B2B invoice: {e}\")\n            return None\n\n    def _process_gstr2b_import_transaction(self, import_data: Dict[str, Any]) -> Optional[GSTTransaction]:\n        \"\"\"Process import transaction from GSTR2B format.\"\"\"\n        try:\n            port_code = import_data.get('port_code', '')\n            bill_num = import_data.get('bill_num', '')\n            bill_date = import_data.get('bill_date', '')\n            \n            total_taxable = float(import_data.get('txval', 0))\n            total_igst = float(import_data.get('iamt', 0))\n            total_cgst = float(import_data.get('camt', 0))\n            total_sgst = float(import_data.get('samt', 0))\n            \n            total_tax = total_igst + total_cgst + total_sgst\n            total_value = total_taxable + total_tax\n            \n            return GSTTransaction(\n                date=self._format_date(bill_date),\n                party_name=f\"Import-{port_code}\",\n                party_gstin=\"\",\n                party_state=\"Import\",\n                invoice_number=bill_num,\n                invoice_date=bill_date,\n                taxable_value=total_taxable,\n                igst_amount=total_igst,\n                cgst_amount=total_cgst,\n                sgst_amount=total_sgst,\n                total_tax=total_tax,\n                invoice_value=total_value,\n                is_interstate=True,  # Imports are always interstate\n                transaction_type='purchase'\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error processing GSTR2B import transaction: {e}\")\n            return None\n\n    def _process_gstr2b_isd_transaction(self, isd_data: Dict[str, Any]) -> Optional[GSTTransaction]:\n        \"\"\"Process ISD credit transaction from GSTR2B format.\"\"\"\n        try:\n            isd_gstin = isd_data.get('isd_gstin', '')\n            doc_num = isd_data.get('doc_num', '')\n            doc_date = isd_data.get('doc_date', '')\n            \n            total_igst = float(isd_data.get('iamt', 0))\n            total_cgst = float(isd_data.get('camt', 0))\n            total_sgst = float(isd_data.get('samt', 0))\n            \n            total_tax = total_igst + total_cgst + total_sgst\n            \n            return GSTTransaction(\n                date=self._format_date(doc_date),\n                party_name=f\"ISD-{isd_gstin[:10]}\",\n                party_gstin=isd_gstin,\n                party_state=self._get_state_from_gstin(isd_gstin),\n                invoice_number=doc_num,\n                invoice_date=doc_date,\n                taxable_value=0,  # ISD credits don't have taxable value\n                igst_amount=total_igst,\n                cgst_amount=total_cgst,\n                sgst_amount=total_sgst,\n                total_tax=total_tax,\n                invoice_value=total_tax,\n                is_interstate=total_igst > 0,\n                transaction_type='purchase'\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error processing GSTR2B ISD transaction: {e}\")\n            return None\n\n    def _process_gstr2a_b2b_invoice(self, invoice: Dict[str, Any], supplier_gstin: str, \n                                  supplier_state: str) -> Optional[GSTTransaction]:\n        \"\"\"Process a B2B invoice from GSTR2A format.\"\"\"\n        try:\n            invoice_number = invoice.get('inum', '')\n            invoice_date = invoice.get('idt', '')\n            invoice_value = float(invoice.get('val', 0))\n            \n            # GSTR2A structure similar to GSTR1 for items\n            total_taxable = 0\n            total_igst = 0\n            total_cgst = 0\n            total_sgst = 0\n            \n            for item in invoice.get('itms', []):\n                for itm_det in item.get('itm_det', []):\n                    total_taxable += float(itm_det.get('txval', 0))\n                    total_igst += float(itm_det.get('iamt', 0))\n                    total_cgst += float(itm_det.get('camt', 0))\n                    total_sgst += float(itm_det.get('samt', 0))\n            \n            total_tax = total_igst + total_cgst + total_sgst\n            is_interstate = total_igst > 0 or supplier_state != self.company_state\n            \n            party_name = f\"Supplier-{supplier_gstin[:10]}\" if supplier_gstin else \"Unknown Supplier\"\n            \n            return GSTTransaction(\n                date=self._format_date(invoice_date),\n                party_name=party_name,\n                party_gstin=supplier_gstin,\n                party_state=supplier_state,\n                invoice_number=invoice_number,\n                invoice_date=invoice_date,\n                taxable_value=total_taxable,\n                igst_amount=total_igst,\n                cgst_amount=total_cgst,\n                sgst_amount=total_sgst,\n                total_tax=total_tax,\n                invoice_value=invoice_value,\n                is_interstate=is_interstate,\n                transaction_type='purchase'\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error processing GSTR2A B2B invoice: {e}\")\n            return None\n\n    def _process_gstr2a_import_transaction(self, import_data: Dict[str, Any]) -> Optional[GSTTransaction]:\n        \"\"\"Process import transaction from GSTR2A format.\"\"\"\n        try:\n            # Similar to GSTR2B but may have slightly different field names\n            port_code = import_data.get('port_code', '')\n            bill_num = import_data.get('bill_num', '')\n            bill_date = import_data.get('bill_date', '')\n            \n            total_taxable = float(import_data.get('txval', 0))\n            total_igst = float(import_data.get('iamt', 0))\n            total_cgst = float(import_data.get('camt', 0))\n            total_sgst = float(import_data.get('samt', 0))\n            \n            total_tax = total_igst + total_cgst + total_sgst\n            total_value = total_taxable + total_tax\n            \n            return GSTTransaction(\n                date=self._format_date(bill_date),\n                party_name=f\"Import-{port_code}\",\n                party_gstin=\"\",\n                party_state=\"Import\",\n                invoice_number=bill_num,\n                invoice_date=bill_date,\n                taxable_value=total_taxable,\n                igst_amount=total_igst,\n                cgst_amount=total_cgst,\n                sgst_amount=total_sgst,\n                total_tax=total_tax,\n                invoice_value=total_value,\n                is_interstate=True,\n                transaction_type='purchase'\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error processing GSTR2A import transaction: {e}\")\n            return None\n\n    def _process_b2b_invoice(self, invoice: Dict[str, Any], party_gstin: str, \n                           party_state: str, transaction_type: str) -> Optional[GSTTransaction]:\n        \"\"\"Process a B2B invoice and extract transaction data.\"\"\"\n        try:\n            invoice_number = invoice.get('inum', '')\n            invoice_date = invoice.get('idt', '')\n            invoice_value = float(invoice.get('val', 0))\n            \n            # Process line items and calculate totals\n            total_taxable = 0\n            total_igst = 0\n            total_cgst = 0\n            total_sgst = 0\n            \n            for item in invoice.get('itms', []):\n                for itm_det in item.get('itm_det', []):\n                    total_taxable += float(itm_det.get('txval', 0))\n                    total_igst += float(itm_det.get('iamt', 0))\n                    total_cgst += float(itm_det.get('camt', 0))\n                    total_sgst += float(itm_det.get('samt', 0))\n            \n            total_tax = total_igst + total_cgst + total_sgst\n            is_interstate = total_igst > 0 or party_state != self.company_state\n            \n            # Generate party name from GSTIN if not available\n            party_name = f\"Party-{party_gstin[:10]}\" if party_gstin else \"Unknown Party\"\n            \n            return GSTTransaction(\n                date=self._format_date(invoice_date),\n                party_name=party_name,\n                party_gstin=party_gstin,\n                party_state=party_state,\n                invoice_number=invoice_number,\n                invoice_date=invoice_date,\n                taxable_value=total_taxable,\n                igst_amount=total_igst,\n                cgst_amount=total_cgst,\n                sgst_amount=total_sgst,\n                total_tax=total_tax,\n                invoice_value=invoice_value,\n                is_interstate=is_interstate,\n                transaction_type=transaction_type\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error processing B2B invoice: {e}\")\n            return None\n    \n    def _process_b2cs_transaction(self, b2cs_data: Dict[str, Any], \n                                transaction_type: str) -> Optional[GSTTransaction]:\n        \"\"\"Process B2CS (small) transaction.\"\"\"\n        try:\n            # B2CS doesn't have party details, so create generic entry\n            party_state = b2cs_data.get('stin', self.company_state)  # State of supply\n            total_taxable = float(b2cs_data.get('txval', 0))\n            total_igst = float(b2cs_data.get('iamt', 0))\n            total_cgst = float(b2cs_data.get('camt', 0))\n            total_sgst = float(b2cs_data.get('samt', 0))\n            \n            total_tax = total_igst + total_cgst + total_sgst\n            total_value = total_taxable + total_tax\n            is_interstate = total_igst > 0 or party_state != self.company_state\n            \n            return GSTTransaction(\n                date=datetime.now().strftime(\"%Y-%m-%d\"),  # B2CS doesn't have specific dates\n                party_name=f\"B2CS-{party_state}\",\n                party_gstin=\"\",\n                party_state=party_state,\n                invoice_number=\"B2CS-Consolidated\",\n                invoice_date=\"\",\n                taxable_value=total_taxable,\n                igst_amount=total_igst,\n                cgst_amount=total_cgst,\n                sgst_amount=total_sgst,\n                total_tax=total_tax,\n                invoice_value=total_value,\n                is_interstate=is_interstate,\n                transaction_type=transaction_type\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error processing B2CS transaction: {e}\")\n            return None\n    \n    def _get_state_from_gstin(self, gstin: str) -> str:\n        \"\"\"Extract state from GSTIN.\"\"\"\n        if not gstin or len(gstin) < 2:\n            return self.company_state\n        \n        state_code = gstin[:2]\n        for state, code in self.state_codes.items():\n            if code == state_code:\n                return state\n        \n        return self.company_state\n    \n    def _format_date(self, date_str: str) -> str:\n        \"\"\"Format date to standard format.\"\"\"\n        if not date_str:\n            return datetime.now().strftime(\"%Y-%m-%d\")\n        \n        try:\n            # GST dates are usually in DD-MM-YYYY format\n            if len(date_str) >= 8:\n                dt = datetime.strptime(date_str, \"%d-%m-%Y\")\n                return dt.strftime(\"%Y-%m-%d\")\n        except ValueError:\n            pass\n        \n        return date_str\n    \n    def generate_ledger_name(self, transaction: GSTTransaction, tax_type: str) -> str:\n        \"\"\"\n        Generate descriptive ledger names for GST transactions.\n        \n        Args:\n            transaction: GST transaction\n            tax_type: Type of tax (IGST, CGST, SGST)\n            \n        Returns:\n            Descriptive ledger name\n        \"\"\"\n        # Determine prefix based on transaction type\n        prefix = \"Input\" if transaction.transaction_type == \"purchase\" else \"Output\"\n        \n        # Calculate tax rate\n        if transaction.taxable_value > 0:\n            if tax_type == \"IGST\" and transaction.igst_amount > 0:\n                rate = (transaction.igst_amount / transaction.taxable_value) * 100\n                return f\"{prefix} IGST {rate:.0f}%\"\n            elif tax_type == \"CGST\" and transaction.cgst_amount > 0:\n                rate = (transaction.cgst_amount / transaction.taxable_value) * 100\n                return f\"{prefix} CGST {rate:.0f}%\"\n            elif tax_type == \"SGST\" and transaction.sgst_amount > 0:\n                rate = (transaction.sgst_amount / transaction.taxable_value) * 100\n                return f\"{prefix} SGST {rate:.0f}%\"\n        \n        # Fallback naming\n        return f\"{prefix} {tax_type}\"\n    \n    def generate_main_ledger_name(self, transaction: GSTTransaction) -> str:\n        \"\"\"Generate main ledger name for the transaction.\"\"\"\n        transaction_type = \"Purchase\" if transaction.transaction_type == \"purchase\" else \"Sales\"\n        location = \"Interstate\" if transaction.is_interstate else \"Local\"\n        \n        # Calculate overall tax rate\n        if transaction.taxable_value > 0:\n            total_rate = (transaction.total_tax / transaction.taxable_value) * 100\n            return f\"{location} {transaction_type} {total_rate:.0f}%\"\n        \n        return f\"{location} {transaction_type}\"","size_bytes":26720},"gst_tally_xml_generator.py":{"content":"import xml.etree.ElementTree as ET\nfrom typing import List, Dict, Any\nfrom datetime import datetime\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass GSTTallyXMLGenerator:\n    \"\"\"Generate Tally XML from GST portal JSON data.\"\"\"\n    \n    def __init__(self, company_name: str, company_state: str):\n        \"\"\"\n        Initialize GST Tally XML generator.\n        \n        Args:\n            company_name: Name of the company in Tally\n            company_state: Company's state\n        \"\"\"\n        self.company_name = company_name\n        self.company_state = company_state\n    \n    def generate_gstr2b_xml(self, gstr2b_data: Dict[str, Any]) -> str:\n        \"\"\"Generate Tally XML for GSTR2B (Purchase) data.\"\"\"\n        # Create root envelope\n        envelope = ET.Element(\"ENVELOPE\")\n        \n        # Header\n        header = ET.SubElement(envelope, \"HEADER\")\n        ET.SubElement(header, \"TALLYREQUEST\").text = \"Import Data\"\n        ET.SubElement(header, \"TYPE\").text = \"Data\"\n        ET.SubElement(header, \"ID\").text = \"Vouchers\"\n        \n        # Body\n        body = ET.SubElement(envelope, \"BODY\")\n        import_data = ET.SubElement(body, \"IMPORTDATA\")\n        \n        # Request description\n        request_desc = ET.SubElement(import_data, \"REQUESTDESC\")\n        ET.SubElement(request_desc, \"REPORTNAME\").text = \"Vouchers\"\n        static_vars = ET.SubElement(request_desc, \"STATICVARIABLES\")\n        ET.SubElement(static_vars, \"SVCURRENTCOMPANY\").text = self.company_name\n        \n        # Request data\n        request_data = ET.SubElement(import_data, \"REQUESTDATA\")\n        \n        # Process B2B invoices\n        voucher_number = 1\n        if 'itc_avl' in gstr2b_data and 'b2b' in gstr2b_data['itc_avl']:\n            for vendor in gstr2b_data['itc_avl']['b2b']:\n                vendor_gstin = vendor.get('ctin', '')\n                \n                # Create vendor ledger\n                self._create_vendor_ledger(request_data, vendor_gstin)\n                \n                for invoice in vendor.get('inv', []):\n                    self._add_purchase_voucher_from_gst(request_data, vendor_gstin, invoice, voucher_number)\n                    voucher_number += 1\n        \n        return self._prettify_xml(envelope)\n    \n    def generate_gstr2a_xml(self, gstr2a_data: Dict[str, Any]) -> str:\n        \"\"\"Generate Tally XML for GSTR2A (Purchase) data.\"\"\"\n        # Similar to GSTR2B but with different structure\n        envelope = ET.Element(\"ENVELOPE\")\n        \n        # Header\n        header = ET.SubElement(envelope, \"HEADER\")\n        ET.SubElement(header, \"TALLYREQUEST\").text = \"Import Data\"\n        ET.SubElement(header, \"TYPE\").text = \"Data\"\n        ET.SubElement(header, \"ID\").text = \"Vouchers\"\n        \n        # Body\n        body = ET.SubElement(envelope, \"BODY\")\n        import_data = ET.SubElement(body, \"IMPORTDATA\")\n        \n        # Request description\n        request_desc = ET.SubElement(import_data, \"REQUESTDESC\")\n        ET.SubElement(request_desc, \"REPORTNAME\").text = \"Vouchers\"\n        static_vars = ET.SubElement(request_desc, \"STATICVARIABLES\")\n        ET.SubElement(static_vars, \"SVCURRENTCOMPANY\").text = self.company_name\n        \n        # Request data\n        request_data = ET.SubElement(import_data, \"REQUESTDATA\")\n        \n        # Process B2B invoices\n        voucher_number = 1\n        if 'b2b' in gstr2a_data:\n            for vendor in gstr2a_data['b2b']:\n                vendor_gstin = vendor.get('ctin', '')\n                \n                # Create vendor ledger\n                self._create_vendor_ledger(request_data, vendor_gstin)\n                \n                for invoice in vendor.get('inv', []):\n                    self._add_purchase_voucher_from_gst(request_data, vendor_gstin, invoice, voucher_number)\n                    voucher_number += 1\n        \n        return self._prettify_xml(envelope)\n    \n    def generate_gstr1_xml(self, gstr1_data: Dict[str, Any]) -> str:\n        \"\"\"Generate Tally XML for GSTR1 (Sales) data.\"\"\"\n        envelope = ET.Element(\"ENVELOPE\")\n        \n        # Header\n        header = ET.SubElement(envelope, \"HEADER\")\n        ET.SubElement(header, \"TALLYREQUEST\").text = \"Import Data\"\n        ET.SubElement(header, \"TYPE\").text = \"Data\"\n        ET.SubElement(header, \"ID\").text = \"Vouchers\"\n        \n        # Body\n        body = ET.SubElement(envelope, \"BODY\")\n        import_data = ET.SubElement(body, \"IMPORTDATA\")\n        \n        # Request description\n        request_desc = ET.SubElement(import_data, \"REQUESTDESC\")\n        ET.SubElement(request_desc, \"REPORTNAME\").text = \"Vouchers\"\n        static_vars = ET.SubElement(request_desc, \"STATICVARIABLES\")\n        ET.SubElement(static_vars, \"SVCURRENTCOMPANY\").text = self.company_name\n        \n        # Request data\n        request_data = ET.SubElement(import_data, \"REQUESTDATA\")\n        \n        # Process B2B invoices\n        voucher_number = 1\n        if 'b2b' in gstr1_data:\n            for customer in gstr1_data['b2b']:\n                customer_gstin = customer.get('ctin', '')\n                \n                # Create customer ledger\n                self._create_customer_ledger(request_data, customer_gstin)\n                \n                for invoice in customer.get('inv', []):\n                    self._add_sales_voucher_from_gst(request_data, customer_gstin, invoice, voucher_number)\n                    voucher_number += 1\n        \n        # Process B2CL invoices\n        if 'b2cl' in gstr1_data:\n            for invoice in gstr1_data['b2cl']:\n                self._add_b2cl_sales_voucher(request_data, invoice, voucher_number)\n                voucher_number += 1\n        \n        return self._prettify_xml(envelope)\n    \n    def _create_vendor_ledger(self, parent: ET.Element, vendor_gstin: str):\n        \"\"\"Create vendor ledger.\"\"\"\n        vendor_name = f\"Vendor - {vendor_gstin}\"\n        \n        msg = ET.SubElement(parent, \"TALLYMESSAGE\")\n        msg.set(\"xmlns:UDF\", \"TallyUDF\")\n        ledger = ET.SubElement(msg, \"LEDGER\")\n        ledger.set(\"NAME\", vendor_name)\n        ledger.set(\"ACTION\", \"Create\")\n        ET.SubElement(ledger, \"PARENT\").text = \"Sundry Creditors\"\n        ET.SubElement(ledger, \"ISBILLWISEON\").text = \"Yes\"\n        \n        # Add GSTIN details\n        if vendor_gstin:\n            ET.SubElement(ledger, \"PARTYGSTIN\").text = vendor_gstin\n    \n    def _create_customer_ledger(self, parent: ET.Element, customer_gstin: str):\n        \"\"\"Create customer ledger.\"\"\"\n        customer_name = f\"Customer - {customer_gstin}\"\n        \n        msg = ET.SubElement(parent, \"TALLYMESSAGE\")\n        msg.set(\"xmlns:UDF\", \"TallyUDF\")\n        ledger = ET.SubElement(msg, \"LEDGER\")\n        ledger.set(\"NAME\", customer_name)\n        ledger.set(\"ACTION\", \"Create\")\n        ET.SubElement(ledger, \"PARENT\").text = \"Sundry Debtors\"\n        ET.SubElement(ledger, \"ISBILLWISEON\").text = \"Yes\"\n        \n        # Add GSTIN details\n        if customer_gstin:\n            ET.SubElement(ledger, \"PARTYGSTIN\").text = customer_gstin\n    \n    def _add_purchase_voucher_from_gst(self, parent: ET.Element, vendor_gstin: str, invoice: Dict[str, Any], voucher_number: int):\n        \"\"\"Add purchase voucher from GST data.\"\"\"\n        msg = ET.SubElement(parent, \"TALLYMESSAGE\")\n        msg.set(\"xmlns:UDF\", \"TallyUDF\")\n        voucher = ET.SubElement(msg, \"VOUCHER\")\n        voucher.set(\"VCHTYPE\", \"Purchase\")\n        voucher.set(\"ACTION\", \"Create\")\n        \n        # Voucher details\n        invoice_date = self._format_gst_date(invoice.get('idt', ''))\n        ET.SubElement(voucher, \"DATE\").text = invoice_date\n        ET.SubElement(voucher, \"VOUCHERTYPENAME\").text = \"Purchase\"\n        ET.SubElement(voucher, \"VOUCHERNUMBER\").text = str(voucher_number)\n        ET.SubElement(voucher, \"REFERENCE\").text = invoice.get('inum', '')\n        \n        # Vendor ledger entry (Credit)\n        vendor_name = f\"Vendor - {vendor_gstin}\"\n        vendor_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n        ET.SubElement(vendor_entry, \"LEDGERNAME\").text = vendor_name\n        ET.SubElement(vendor_entry, \"ISDEEMEDPOSITIVE\").text = \"Yes\"\n        ET.SubElement(vendor_entry, \"AMOUNT\").text = f\"-{invoice.get('val', 0):.2f}\"\n        \n        # Process items\n        for item in invoice.get('itms', []):\n            item_det = item.get('itm_det', {})\n            \n            # Purchase entry (Debit)\n            purchase_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n            ET.SubElement(purchase_entry, \"LEDGERNAME\").text = f\"Purchase - HSN {item_det.get('hsn_sc', 'Unknown')}\"\n            ET.SubElement(purchase_entry, \"ISDEEMEDPOSITIVE\").text = \"No\"\n            ET.SubElement(purchase_entry, \"AMOUNT\").text = f\"{item_det.get('txval', 0):.2f}\"\n            \n            # Tax entries\n            if item_det.get('iamt', 0) > 0:\n                # IGST\n                igst_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n                ET.SubElement(igst_entry, \"LEDGERNAME\").text = f\"Input IGST {item_det.get('rt', 0)}%\"\n                ET.SubElement(igst_entry, \"ISDEEMEDPOSITIVE\").text = \"No\"\n                ET.SubElement(igst_entry, \"AMOUNT\").text = f\"{item_det.get('iamt', 0):.2f}\"\n            else:\n                # CGST/SGST\n                if item_det.get('camt', 0) > 0:\n                    cgst_rate = item_det.get('rt', 0) / 2\n                    cgst_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n                    ET.SubElement(cgst_entry, \"LEDGERNAME\").text = f\"Input CGST {cgst_rate}%\"\n                    ET.SubElement(cgst_entry, \"ISDEEMEDPOSITIVE\").text = \"No\"\n                    ET.SubElement(cgst_entry, \"AMOUNT\").text = f\"{item_det.get('camt', 0):.2f}\"\n                \n                if item_det.get('samt', 0) > 0:\n                    sgst_rate = item_det.get('rt', 0) / 2\n                    sgst_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n                    ET.SubElement(sgst_entry, \"LEDGERNAME\").text = f\"Input SGST {sgst_rate}%\"\n                    ET.SubElement(sgst_entry, \"ISDEEMEDPOSITIVE\").text = \"No\"\n                    ET.SubElement(sgst_entry, \"AMOUNT\").text = f\"{item_det.get('samt', 0):.2f}\"\n    \n    def _add_sales_voucher_from_gst(self, parent: ET.Element, customer_gstin: str, invoice: Dict[str, Any], voucher_number: int):\n        \"\"\"Add sales voucher from GST data.\"\"\"\n        msg = ET.SubElement(parent, \"TALLYMESSAGE\")\n        msg.set(\"xmlns:UDF\", \"TallyUDF\")\n        voucher = ET.SubElement(msg, \"VOUCHER\")\n        voucher.set(\"VCHTYPE\", \"Sales\")\n        voucher.set(\"ACTION\", \"Create\")\n        \n        # Voucher details\n        invoice_date = self._format_gst_date(invoice.get('idt', ''))\n        ET.SubElement(voucher, \"DATE\").text = invoice_date\n        ET.SubElement(voucher, \"VOUCHERTYPENAME\").text = \"Sales\"\n        ET.SubElement(voucher, \"VOUCHERNUMBER\").text = str(voucher_number)\n        ET.SubElement(voucher, \"REFERENCE\").text = invoice.get('inum', '')\n        \n        # Customer ledger entry (Debit)\n        customer_name = f\"Customer - {customer_gstin}\"\n        customer_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n        ET.SubElement(customer_entry, \"LEDGERNAME\").text = customer_name\n        ET.SubElement(customer_entry, \"ISDEEMEDPOSITIVE\").text = \"No\"\n        ET.SubElement(customer_entry, \"AMOUNT\").text = f\"{invoice.get('val', 0):.2f}\"\n        \n        # Process items\n        for item in invoice.get('itms', []):\n            item_det = item.get('itm_det', {})\n            \n            # Sales entry (Credit)\n            sales_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n            ET.SubElement(sales_entry, \"LEDGERNAME\").text = f\"Sales - HSN {item_det.get('hsn_sc', 'Unknown')}\"\n            ET.SubElement(sales_entry, \"ISDEEMEDPOSITIVE\").text = \"Yes\"\n            ET.SubElement(sales_entry, \"AMOUNT\").text = f\"-{item_det.get('txval', 0):.2f}\"\n            \n            # Tax entries\n            if item_det.get('iamt', 0) > 0:\n                # IGST\n                igst_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n                ET.SubElement(igst_entry, \"LEDGERNAME\").text = f\"Output IGST {item_det.get('rt', 0)}%\"\n                ET.SubElement(igst_entry, \"ISDEEMEDPOSITIVE\").text = \"Yes\"\n                ET.SubElement(igst_entry, \"AMOUNT\").text = f\"-{item_det.get('iamt', 0):.2f}\"\n            else:\n                # CGST/SGST\n                if item_det.get('camt', 0) > 0:\n                    cgst_rate = item_det.get('rt', 0) / 2\n                    cgst_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n                    ET.SubElement(cgst_entry, \"LEDGERNAME\").text = f\"Output CGST {cgst_rate}%\"\n                    ET.SubElement(cgst_entry, \"ISDEEMEDPOSITIVE\").text = \"Yes\"\n                    ET.SubElement(cgst_entry, \"AMOUNT\").text = f\"-{item_det.get('camt', 0):.2f}\"\n                \n                if item_det.get('samt', 0) > 0:\n                    sgst_rate = item_det.get('rt', 0) / 2\n                    sgst_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n                    ET.SubElement(sgst_entry, \"LEDGERNAME\").text = f\"Output SGST {sgst_rate}%\"\n                    ET.SubElement(sgst_entry, \"ISDEEMEDPOSITIVE\").text = \"Yes\"\n                    ET.SubElement(sgst_entry, \"AMOUNT\").text = f\"-{item_det.get('samt', 0):.2f}\"\n    \n    def _add_b2cl_sales_voucher(self, parent: ET.Element, invoice: Dict[str, Any], voucher_number: int):\n        \"\"\"Add B2CL sales voucher.\"\"\"\n        msg = ET.SubElement(parent, \"TALLYMESSAGE\")\n        msg.set(\"xmlns:UDF\", \"TallyUDF\")\n        voucher = ET.SubElement(msg, \"VOUCHER\")\n        voucher.set(\"VCHTYPE\", \"Sales\")\n        voucher.set(\"ACTION\", \"Create\")\n        \n        # Voucher details\n        invoice_date = self._format_gst_date(invoice.get('idt', ''))\n        ET.SubElement(voucher, \"DATE\").text = invoice_date\n        ET.SubElement(voucher, \"VOUCHERTYPENAME\").text = \"Sales\"\n        ET.SubElement(voucher, \"VOUCHERNUMBER\").text = str(voucher_number)\n        ET.SubElement(voucher, \"REFERENCE\").text = invoice.get('inum', '')\n        \n        # Customer ledger entry (Debit) - use generic B2CL customer\n        customer_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n        ET.SubElement(customer_entry, \"LEDGERNAME\").text = \"B2CL Customers\"\n        ET.SubElement(customer_entry, \"ISDEEMEDPOSITIVE\").text = \"No\"\n        ET.SubElement(customer_entry, \"AMOUNT\").text = f\"{invoice.get('val', 0):.2f}\"\n        \n        # Process items\n        for item in invoice.get('itms', []):\n            item_det = item.get('itm_det', {})\n            \n            # Sales entry (Credit)\n            sales_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n            ET.SubElement(sales_entry, \"LEDGERNAME\").text = f\"Sales - HSN {item_det.get('hsn_sc', 'Unknown')}\"\n            ET.SubElement(sales_entry, \"ISDEEMEDPOSITIVE\").text = \"Yes\"\n            ET.SubElement(sales_entry, \"AMOUNT\").text = f\"-{item_det.get('txval', 0):.2f}\"\n            \n            # Tax entries (similar to B2B)\n            if item_det.get('iamt', 0) > 0:\n                igst_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n                ET.SubElement(igst_entry, \"LEDGERNAME\").text = f\"Output IGST {item_det.get('rt', 0)}%\"\n                ET.SubElement(igst_entry, \"ISDEEMEDPOSITIVE\").text = \"Yes\"\n                ET.SubElement(igst_entry, \"AMOUNT\").text = f\"-{item_det.get('iamt', 0):.2f}\"\n            else:\n                if item_det.get('camt', 0) > 0:\n                    cgst_rate = item_det.get('rt', 0) / 2\n                    cgst_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n                    ET.SubElement(cgst_entry, \"LEDGERNAME\").text = f\"Output CGST {cgst_rate}%\"\n                    ET.SubElement(cgst_entry, \"ISDEEMEDPOSITIVE\").text = \"Yes\"\n                    ET.SubElement(cgst_entry, \"AMOUNT\").text = f\"-{item_det.get('camt', 0):.2f}\"\n                \n                if item_det.get('samt', 0) > 0:\n                    sgst_rate = item_det.get('rt', 0) / 2\n                    sgst_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n                    ET.SubElement(sgst_entry, \"LEDGERNAME\").text = f\"Output SGST {sgst_rate}%\"\n                    ET.SubElement(sgst_entry, \"ISDEEMEDPOSITIVE\").text = \"Yes\"\n                    ET.SubElement(sgst_entry, \"AMOUNT\").text = f\"-{item_det.get('samt', 0):.2f}\"\n    \n    def _format_gst_date(self, date_str: str) -> str:\n        \"\"\"Format GST date to Tally format.\"\"\"\n        if not date_str:\n            return datetime.now().strftime(\"%Y%m%d\")\n        \n        try:\n            # GST dates are usually in DD-MM-YYYY format\n            if '-' in date_str:\n                dt = datetime.strptime(date_str, \"%d-%m-%Y\")\n                return dt.strftime(\"%Y%m%d\")\n            else:\n                return datetime.now().strftime(\"%Y%m%d\")\n        except Exception as e:\n            logger.error(f\"Error formatting GST date {date_str}: {e}\")\n            return datetime.now().strftime(\"%Y%m%d\")\n    \n    def _prettify_xml(self, element: ET.Element) -> str:\n        \"\"\"Convert XML element to prettified string.\"\"\"\n        xml_str = ET.tostring(element, encoding='unicode')\n        xml_declaration = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n'\n        \n        # Basic prettification\n        lines = xml_str.split('>')\n        formatted_lines = []\n        indent_level = 0\n        \n        for line in lines:\n            line = line.strip()\n            if not line:\n                continue\n                \n            if line.startswith('</'):\n                indent_level -= 1\n            \n            formatted_lines.append('  ' * indent_level + line + '>')\n            \n            if not line.startswith('</') and not line.endswith('/>') and '</' not in line:\n                indent_level += 1\n        \n        formatted_xml = xml_declaration + '\\n'.join(formatted_lines)\n        return formatted_xml.replace('>>', '>')","size_bytes":17888},"invoice_extractor.py":{"content":"import json\nimport logging\nimport os\nfrom typing import List, Dict, Any, Optional\n\nfrom google import genai\nfrom google.genai import types\nfrom pydantic import BaseModel\nfrom PIL import Image\nimport io\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nclass InvoiceItem(BaseModel):\n    description: str\n    hsn_code: Optional[str] = None\n    quantity: float\n    unit: str\n    rate: float\n    taxable_value: float\n    cgst_rate: Optional[float] = None\n    cgst_amount: Optional[float] = None\n    sgst_rate: Optional[float] = None\n    sgst_amount: Optional[float] = None\n    igst_rate: Optional[float] = None\n    igst_amount: Optional[float] = None\n    total_amount: float\n\nclass Invoice(BaseModel):\n    invoice_number: str\n    invoice_date: str\n    vendor_name: str\n    vendor_gstin: Optional[str] = None\n    vendor_address: str\n    vendor_state: Optional[str] = None\n    buyer_name: Optional[str] = None\n    buyer_gstin: Optional[str] = None\n    buyer_address: Optional[str] = None\n    buyer_state: Optional[str] = None\n    total_taxable_value: float\n    total_cgst: Optional[float] = None\n    total_sgst: Optional[float] = None\n    total_igst: Optional[float] = None\n    total_tax_amount: float\n    total_invoice_value: float\n    items: List[InvoiceItem]\n    invoice_type: str  # 'purchase' or 'sales'\n\nclass InvoiceExtractor:\n    def __init__(self):\n        \"\"\"Initialize the invoice extractor with Gemini client.\"\"\"\n        api_key = os.environ.get(\"GEMINI_API_KEY\")\n        if not api_key:\n            raise ValueError(\"GEMINI_API_KEY environment variable is required\")\n        \n        self.client = genai.Client(api_key=api_key)\n    \n    def extract_invoice_data(self, image_bytes: bytes, invoice_type: str, company_state: str) -> Dict[str, Any]:\n        \"\"\"\n        Extract invoice data from image.\n        \n        Args:\n            image_bytes: Image data as bytes\n            invoice_type: 'purchase' or 'sales'\n            company_state: Company's state for GST calculation\n            \n        Returns:\n            Invoice data dictionary\n        \"\"\"\n        try:\n            # Create prompt based on invoice type\n            if invoice_type.lower() == 'purchase':\n                prompt = self._get_purchase_invoice_prompt(company_state)\n            else:\n                prompt = self._get_sales_invoice_prompt(company_state)\n            \n            # Optimize image before processing\n            optimized_image_bytes = self._optimize_image(image_bytes)\n            \n            # Generate content with image analysis\n            response = self.client.models.generate_content(\n                model=\"gemini-2.5-flash\",\n                contents=[\n                    types.Part.from_bytes(\n                        data=optimized_image_bytes,\n                        mime_type=\"image/png\",\n                    ),\n                    prompt\n                ],\n                config=types.GenerateContentConfig(\n                    response_mime_type=\"application/json\",\n                ),\n            )\n\n            if not response.text:\n                logger.error(\"Empty response from Gemini API\")\n                return {}\n\n            # Parse JSON response with validation\n            try:\n                invoice_data = json.loads(response.text)\n                \n                # Validate basic structure\n                if not isinstance(invoice_data, dict):\n                    logger.error(\"Response is not a valid dictionary\")\n                    return {}\n                \n                # Ensure required fields exist\n                required_fields = ['invoice_number', 'invoice_date', 'total_invoice_value']\n                for field in required_fields:\n                    if field not in invoice_data:\n                        logger.warning(f\"Missing required field: {field}\")\n                \n                # Ensure items is a list\n                if 'items' not in invoice_data or not isinstance(invoice_data['items'], list):\n                    invoice_data['items'] = []\n                \n                logger.info(f\"Successfully extracted invoice data with {len(invoice_data.get('items', []))} items\")\n                \n                # Add invoice type to the data\n                invoice_data['invoice_type'] = invoice_type.lower()\n                \n                return invoice_data\n            except json.JSONDecodeError as e:\n                logger.error(f\"Failed to parse JSON response: {e}\")\n                logger.error(f\"Raw response: {response.text}\")\n                return {}\n            except Exception as e:\n                logger.error(f\"Error processing invoice data: {e}\")\n                return {}\n\n        except Exception as e:\n            logger.error(f\"Error extracting invoice data: {e}\")\n            return {}\n    \n    def _get_purchase_invoice_prompt(self, company_state: str) -> str:\n        \"\"\"Get prompt for purchase invoice extraction.\"\"\"\n        return f\"\"\"Extract all information from this purchase invoice as JSON.\n\nCompany state: {company_state}\n\nRequired fields:\n- invoice_number: Invoice/Bill number\n- invoice_date: Date (YYYY-MM-DD format)\n- vendor_name: Supplier/Vendor name\n- vendor_gstin: Vendor GST number (if available)\n- vendor_address: Vendor address\n- vendor_state: Vendor state name (if identifiable)\n- total_taxable_value: Total taxable amount before tax\n- total_cgst: Total CGST amount (if intrastate)\n- total_sgst: Total SGST amount (if intrastate)\n- total_igst: Total IGST amount (if interstate)\n- total_tax_amount: Total tax amount\n- total_invoice_value: Final invoice amount\n- items: Array of line items with:\n  - description: Item description\n  - hsn_code: HSN/SAC code (if available)\n  - quantity: Quantity\n  - unit: Unit of measurement\n  - rate: Rate per unit\n  - taxable_value: Taxable amount for this item\n  - cgst_rate: CGST rate % (if intrastate)\n  - cgst_amount: CGST amount (if intrastate)\n  - sgst_rate: SGST rate % (if intrastate)\n  - sgst_amount: SGST amount (if intrastate)\n  - igst_rate: IGST rate % (if interstate)\n  - igst_amount: IGST amount (if interstate)\n  - total_amount: Total amount for this item\n\nImportant: \n- If vendor state is same as {company_state}, use CGST+SGST\n- If vendor state is different from {company_state}, use IGST\n- Return only valid JSON\"\"\"\n\n    def _get_sales_invoice_prompt(self, company_state: str) -> str:\n        \"\"\"Get prompt for sales invoice extraction.\"\"\"\n        return f\"\"\"Extract all information from this sales invoice as JSON.\n\nCompany state: {company_state}\n\nRequired fields:\n- invoice_number: Invoice number\n- invoice_date: Date (YYYY-MM-DD format)\n- buyer_name: Customer/Buyer name\n- buyer_gstin: Buyer GST number (if available)\n- buyer_address: Buyer address\n- buyer_state: Buyer state name (if identifiable)\n- total_taxable_value: Total taxable amount before tax\n- total_cgst: Total CGST amount (if intrastate)\n- total_sgst: Total SGST amount (if intrastate)\n- total_igst: Total IGST amount (if interstate)\n- total_tax_amount: Total tax amount\n- total_invoice_value: Final invoice amount\n- items: Array of line items with:\n  - description: Item description\n  - hsn_code: HSN/SAC code (if available)\n  - quantity: Quantity\n  - unit: Unit of measurement\n  - rate: Rate per unit\n  - taxable_value: Taxable amount for this item\n  - cgst_rate: CGST rate % (if intrastate)\n  - cgst_amount: CGST amount (if intrastate)\n  - sgst_rate: SGST rate % (if intrastate)\n  - sgst_amount: SGST amount (if intrastate)\n  - igst_rate: IGST rate % (if interstate)\n  - igst_amount: IGST amount (if interstate)\n  - total_amount: Total amount for this item\n\nImportant: \n- If buyer state is same as {company_state}, use CGST+SGST\n- If buyer state is different from {company_state}, use IGST\n- Return only valid JSON\"\"\"\n    \n    def _optimize_image(self, image_bytes: bytes) -> bytes:\n        \"\"\"Optimize image for processing.\"\"\"\n        try:\n            # Open image\n            image = Image.open(io.BytesIO(image_bytes))\n            \n            # Convert to RGB if needed\n            if image.mode != 'RGB':\n                image = image.convert('RGB')\n            \n            # Resize if too large (max 2048x2048)\n            max_size = 2048\n            if max(image.size) > max_size:\n                ratio = max_size / max(image.size)\n                new_size = (int(image.size[0] * ratio), int(image.size[1] * ratio))\n                image = image.resize(new_size, Image.Resampling.LANCZOS)\n            \n            # Save as PNG with optimization\n            output = io.BytesIO()\n            image.save(output, format='PNG', optimize=True)\n            return output.getvalue()\n            \n        except Exception as e:\n            logger.warning(f\"Image optimization failed: {e}, using original\")\n            return image_bytes","size_bytes":8818},"invoice_xml_generator.py":{"content":"import xml.etree.ElementTree as ET\nfrom typing import List, Dict, Any\nfrom datetime import datetime\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass InvoiceXMLGenerator:\n    def __init__(self, company_name: str, company_state: str):\n        \"\"\"\n        Initialize Invoice XML generator.\n        \n        Args:\n            company_name: Name of the company in Tally\n            company_state: Company state for GST calculations\n        \"\"\"\n        self.company_name = company_name\n        self.company_state = company_state\n        \n    def generate_purchase_xml(self, invoice_data: Dict[str, Any]) -> str:\n        \"\"\"Generate Tally XML for purchase invoice.\"\"\"\n        # Create root envelope\n        envelope = ET.Element(\"ENVELOPE\")\n        \n        # Header\n        header = ET.SubElement(envelope, \"HEADER\")\n        ET.SubElement(header, \"TALLYREQUEST\").text = \"Import Data\"\n        ET.SubElement(header, \"TYPE\").text = \"Data\"\n        ET.SubElement(header, \"ID\").text = \"Vouchers\"\n        \n        # Body\n        body = ET.SubElement(envelope, \"BODY\")\n        import_data = ET.SubElement(body, \"IMPORTDATA\")\n        \n        # Request description\n        request_desc = ET.SubElement(import_data, \"REQUESTDESC\")\n        ET.SubElement(request_desc, \"REPORTNAME\").text = \"Vouchers\"\n        static_vars = ET.SubElement(request_desc, \"STATICVARIABLES\")\n        ET.SubElement(static_vars, \"SVCURRENTCOMPANY\").text = self.company_name\n        \n        # Request data\n        request_data = ET.SubElement(import_data, \"REQUESTDATA\")\n        \n        # Create ledgers if they don't exist\n        self._add_purchase_ledgers(request_data, invoice_data)\n        \n        # Add purchase voucher\n        self._add_purchase_voucher(request_data, invoice_data)\n        \n        return self._prettify_xml(envelope)\n    \n    def generate_sales_xml(self, invoice_data: Dict[str, Any]) -> str:\n        \"\"\"Generate Tally XML for sales invoice.\"\"\"\n        # Create root envelope\n        envelope = ET.Element(\"ENVELOPE\")\n        \n        # Header\n        header = ET.SubElement(envelope, \"HEADER\")\n        ET.SubElement(header, \"TALLYREQUEST\").text = \"Import Data\"\n        ET.SubElement(header, \"TYPE\").text = \"Data\"\n        ET.SubElement(header, \"ID\").text = \"Vouchers\"\n        \n        # Body\n        body = ET.SubElement(envelope, \"BODY\")\n        import_data = ET.SubElement(body, \"IMPORTDATA\")\n        \n        # Request description\n        request_desc = ET.SubElement(import_data, \"REQUESTDESC\")\n        ET.SubElement(request_desc, \"REPORTNAME\").text = \"Vouchers\"\n        static_vars = ET.SubElement(request_desc, \"STATICVARIABLES\")\n        ET.SubElement(static_vars, \"SVCURRENTCOMPANY\").text = self.company_name\n        \n        # Request data\n        request_data = ET.SubElement(import_data, \"REQUESTDATA\")\n        \n        # Create ledgers if they don't exist\n        self._add_sales_ledgers(request_data, invoice_data)\n        \n        # Add sales voucher\n        self._add_sales_voucher(request_data, invoice_data)\n        \n        return self._prettify_xml(envelope)\n    \n    def _add_purchase_ledgers(self, parent: ET.Element, invoice_data: Dict[str, Any]):\n        \"\"\"Add required ledgers for purchase invoice.\"\"\"\n        vendor_name = invoice_data.get('vendor_name', 'Unknown Vendor')\n        \n        # Vendor ledger\n        vendor_msg = ET.SubElement(parent, \"TALLYMESSAGE\")\n        vendor_msg.set(\"xmlns:UDF\", \"TallyUDF\")\n        vendor_ledger = ET.SubElement(vendor_msg, \"LEDGER\")\n        vendor_ledger.set(\"NAME\", vendor_name)\n        vendor_ledger.set(\"ACTION\", \"Create\")\n        ET.SubElement(vendor_ledger, \"PARENT\").text = \"Sundry Creditors\"\n        ET.SubElement(vendor_ledger, \"ISBILLWISEON\").text = \"Yes\"\n        \n        # Tax ledgers based on interstate/intrastate\n        is_interstate = self._is_interstate_transaction(invoice_data.get('vendor_state'))\n        \n        if is_interstate:\n            # IGST ledgers\n            for item in invoice_data.get('items', []):\n                if item.get('igst_rate'):\n                    igst_rate = item['igst_rate']\n                    igst_ledger_name = f\"Input IGST {igst_rate}%\"\n                    self._create_tax_ledger(parent, igst_ledger_name, \"Duties & Taxes\")\n        else:\n            # CGST/SGST ledgers\n            for item in invoice_data.get('items', []):\n                if item.get('cgst_rate'):\n                    cgst_rate = item['cgst_rate']\n                    sgst_rate = item.get('sgst_rate', cgst_rate)\n                    cgst_ledger_name = f\"Input CGST {cgst_rate}%\"\n                    sgst_ledger_name = f\"Input SGST {sgst_rate}%\"\n                    self._create_tax_ledger(parent, cgst_ledger_name, \"Duties & Taxes\")\n                    self._create_tax_ledger(parent, sgst_ledger_name, \"Duties & Taxes\")\n        \n        # Purchase ledgers for items\n        for item in invoice_data.get('items', []):\n            description = item.get('description', 'Purchase Item')\n            purchase_ledger_name = f\"Purchase - {description[:30]}\"\n            self._create_expense_ledger(parent, purchase_ledger_name)\n    \n    def _add_sales_ledgers(self, parent: ET.Element, invoice_data: Dict[str, Any]):\n        \"\"\"Add required ledgers for sales invoice.\"\"\"\n        buyer_name = invoice_data.get('buyer_name', 'Unknown Customer')\n        \n        # Customer ledger\n        customer_msg = ET.SubElement(parent, \"TALLYMESSAGE\")\n        customer_msg.set(\"xmlns:UDF\", \"TallyUDF\")\n        customer_ledger = ET.SubElement(customer_msg, \"LEDGER\")\n        customer_ledger.set(\"NAME\", buyer_name)\n        customer_ledger.set(\"ACTION\", \"Create\")\n        ET.SubElement(customer_ledger, \"PARENT\").text = \"Sundry Debtors\"\n        ET.SubElement(customer_ledger, \"ISBILLWISEON\").text = \"Yes\"\n        \n        # Tax ledgers based on interstate/intrastate\n        is_interstate = self._is_interstate_transaction(invoice_data.get('buyer_state'))\n        \n        if is_interstate:\n            # IGST ledgers\n            for item in invoice_data.get('items', []):\n                if item.get('igst_rate'):\n                    igst_rate = item['igst_rate']\n                    igst_ledger_name = f\"Output IGST {igst_rate}%\"\n                    self._create_tax_ledger(parent, igst_ledger_name, \"Duties & Taxes\")\n        else:\n            # CGST/SGST ledgers\n            for item in invoice_data.get('items', []):\n                if item.get('cgst_rate'):\n                    cgst_rate = item['cgst_rate']\n                    sgst_rate = item.get('sgst_rate', cgst_rate)\n                    cgst_ledger_name = f\"Output CGST {cgst_rate}%\"\n                    sgst_ledger_name = f\"Output SGST {sgst_rate}%\"\n                    self._create_tax_ledger(parent, cgst_ledger_name, \"Duties & Taxes\")\n                    self._create_tax_ledger(parent, sgst_ledger_name, \"Duties & Taxes\")\n        \n        # Sales ledgers for items\n        for item in invoice_data.get('items', []):\n            description = item.get('description', 'Sales Item')\n            sales_ledger_name = f\"Sales - {description[:30]}\"\n            self._create_income_ledger(parent, sales_ledger_name)\n    \n    def _create_tax_ledger(self, parent: ET.Element, ledger_name: str, parent_group: str):\n        \"\"\"Create a tax ledger.\"\"\"\n        msg = ET.SubElement(parent, \"TALLYMESSAGE\")\n        msg.set(\"xmlns:UDF\", \"TallyUDF\")\n        ledger = ET.SubElement(msg, \"LEDGER\")\n        ledger.set(\"NAME\", ledger_name)\n        ledger.set(\"ACTION\", \"Create\")\n        ET.SubElement(ledger, \"PARENT\").text = parent_group\n        ET.SubElement(ledger, \"TAXTYPE\").text = \"GST\"\n    \n    def _create_expense_ledger(self, parent: ET.Element, ledger_name: str):\n        \"\"\"Create an expense ledger for purchases.\"\"\"\n        msg = ET.SubElement(parent, \"TALLYMESSAGE\")\n        msg.set(\"xmlns:UDF\", \"TallyUDF\")\n        ledger = ET.SubElement(msg, \"LEDGER\")\n        ledger.set(\"NAME\", ledger_name)\n        ledger.set(\"ACTION\", \"Create\")\n        ET.SubElement(ledger, \"PARENT\").text = \"Purchase Accounts\"\n    \n    def _create_income_ledger(self, parent: ET.Element, ledger_name: str):\n        \"\"\"Create an income ledger for sales.\"\"\"\n        msg = ET.SubElement(parent, \"TALLYMESSAGE\")\n        msg.set(\"xmlns:UDF\", \"TallyUDF\")\n        ledger = ET.SubElement(msg, \"LEDGER\")\n        ledger.set(\"NAME\", ledger_name)\n        ledger.set(\"ACTION\", \"Create\")\n        ET.SubElement(ledger, \"PARENT\").text = \"Sales Accounts\"\n    \n    def _add_purchase_voucher(self, parent: ET.Element, invoice_data: Dict[str, Any]):\n        \"\"\"Add purchase voucher to XML.\"\"\"\n        msg = ET.SubElement(parent, \"TALLYMESSAGE\")\n        msg.set(\"xmlns:UDF\", \"TallyUDF\")\n        voucher = ET.SubElement(msg, \"VOUCHER\")\n        voucher.set(\"VCHTYPE\", \"Purchase\")\n        voucher.set(\"ACTION\", \"Create\")\n        \n        # Voucher details\n        invoice_date = self._format_date(invoice_data.get('invoice_date', ''))\n        ET.SubElement(voucher, \"DATE\").text = invoice_date\n        ET.SubElement(voucher, \"VOUCHERTYPENAME\").text = \"Purchase\"\n        ET.SubElement(voucher, \"VOUCHERNUMBER\").text = invoice_data.get('invoice_number', '')\n        ET.SubElement(voucher, \"REFERENCE\").text = invoice_data.get('invoice_number', '')\n        \n        # Vendor ledger entry (Credit)\n        vendor_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n        ET.SubElement(vendor_entry, \"LEDGERNAME\").text = invoice_data.get('vendor_name', 'Unknown Vendor')\n        ET.SubElement(vendor_entry, \"ISDEEMEDPOSITIVE\").text = \"Yes\"\n        ET.SubElement(vendor_entry, \"AMOUNT\").text = f\"-{invoice_data.get('total_invoice_value', 0):.2f}\"\n        \n        # Item and tax entries\n        is_interstate = self._is_interstate_transaction(invoice_data.get('vendor_state'))\n        \n        for item in invoice_data.get('items', []):\n            # Purchase item entry (Debit)\n            item_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n            item_ledger_name = f\"Purchase - {item.get('description', 'Item')[:30]}\"\n            ET.SubElement(item_entry, \"LEDGERNAME\").text = item_ledger_name\n            ET.SubElement(item_entry, \"ISDEEMEDPOSITIVE\").text = \"No\"\n            ET.SubElement(item_entry, \"AMOUNT\").text = f\"{item.get('taxable_value', 0):.2f}\"\n            \n            # Tax entries (Debit)\n            if is_interstate and item.get('igst_amount', 0) > 0:\n                igst_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n                ET.SubElement(igst_entry, \"LEDGERNAME\").text = f\"Input IGST {item.get('igst_rate', 0)}%\"\n                ET.SubElement(igst_entry, \"ISDEEMEDPOSITIVE\").text = \"No\"\n                ET.SubElement(igst_entry, \"AMOUNT\").text = f\"{item.get('igst_amount', 0):.2f}\"\n            else:\n                if item.get('cgst_amount', 0) > 0:\n                    cgst_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n                    ET.SubElement(cgst_entry, \"LEDGERNAME\").text = f\"Input CGST {item.get('cgst_rate', 0)}%\"\n                    ET.SubElement(cgst_entry, \"ISDEEMEDPOSITIVE\").text = \"No\"\n                    ET.SubElement(cgst_entry, \"AMOUNT\").text = f\"{item.get('cgst_amount', 0):.2f}\"\n                \n                if item.get('sgst_amount', 0) > 0:\n                    sgst_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n                    ET.SubElement(sgst_entry, \"LEDGERNAME\").text = f\"Input SGST {item.get('sgst_rate', 0)}%\"\n                    ET.SubElement(sgst_entry, \"ISDEEMEDPOSITIVE\").text = \"No\"\n                    ET.SubElement(sgst_entry, \"AMOUNT\").text = f\"{item.get('sgst_amount', 0):.2f}\"\n    \n    def _add_sales_voucher(self, parent: ET.Element, invoice_data: Dict[str, Any]):\n        \"\"\"Add sales voucher to XML.\"\"\"\n        msg = ET.SubElement(parent, \"TALLYMESSAGE\")\n        msg.set(\"xmlns:UDF\", \"TallyUDF\")\n        voucher = ET.SubElement(msg, \"VOUCHER\")\n        voucher.set(\"VCHTYPE\", \"Sales\")\n        voucher.set(\"ACTION\", \"Create\")\n        \n        # Voucher details\n        invoice_date = self._format_date(invoice_data.get('invoice_date', ''))\n        ET.SubElement(voucher, \"DATE\").text = invoice_date\n        ET.SubElement(voucher, \"VOUCHERTYPENAME\").text = \"Sales\"\n        ET.SubElement(voucher, \"VOUCHERNUMBER\").text = invoice_data.get('invoice_number', '')\n        ET.SubElement(voucher, \"REFERENCE\").text = invoice_data.get('invoice_number', '')\n        \n        # Customer ledger entry (Debit)\n        customer_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n        ET.SubElement(customer_entry, \"LEDGERNAME\").text = invoice_data.get('buyer_name', 'Unknown Customer')\n        ET.SubElement(customer_entry, \"ISDEEMEDPOSITIVE\").text = \"No\"\n        ET.SubElement(customer_entry, \"AMOUNT\").text = f\"{invoice_data.get('total_invoice_value', 0):.2f}\"\n        \n        # Item and tax entries\n        is_interstate = self._is_interstate_transaction(invoice_data.get('buyer_state'))\n        \n        for item in invoice_data.get('items', []):\n            # Sales item entry (Credit)\n            item_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n            item_ledger_name = f\"Sales - {item.get('description', 'Item')[:30]}\"\n            ET.SubElement(item_entry, \"LEDGERNAME\").text = item_ledger_name\n            ET.SubElement(item_entry, \"ISDEEMEDPOSITIVE\").text = \"Yes\"\n            ET.SubElement(item_entry, \"AMOUNT\").text = f\"-{item.get('taxable_value', 0):.2f}\"\n            \n            # Tax entries (Credit)\n            if is_interstate and item.get('igst_amount', 0) > 0:\n                igst_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n                ET.SubElement(igst_entry, \"LEDGERNAME\").text = f\"Output IGST {item.get('igst_rate', 0)}%\"\n                ET.SubElement(igst_entry, \"ISDEEMEDPOSITIVE\").text = \"Yes\"\n                ET.SubElement(igst_entry, \"AMOUNT\").text = f\"-{item.get('igst_amount', 0):.2f}\"\n            else:\n                if item.get('cgst_amount', 0) > 0:\n                    cgst_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n                    ET.SubElement(cgst_entry, \"LEDGERNAME\").text = f\"Output CGST {item.get('cgst_rate', 0)}%\"\n                    ET.SubElement(cgst_entry, \"ISDEEMEDPOSITIVE\").text = \"Yes\"\n                    ET.SubElement(cgst_entry, \"AMOUNT\").text = f\"-{item.get('cgst_amount', 0):.2f}\"\n                \n                if item.get('sgst_amount', 0) > 0:\n                    sgst_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n                    ET.SubElement(sgst_entry, \"LEDGERNAME\").text = f\"Output SGST {item.get('sgst_rate', 0)}%\"\n                    ET.SubElement(sgst_entry, \"ISDEEMEDPOSITIVE\").text = \"Yes\"\n                    ET.SubElement(sgst_entry, \"AMOUNT\").text = f\"-{item.get('sgst_amount', 0):.2f}\"\n    \n    def _is_interstate_transaction(self, other_state: str | None) -> bool:\n        \"\"\"Check if transaction is interstate.\"\"\"\n        if not other_state:\n            return False\n        return other_state.strip().lower() != self.company_state.strip().lower()\n    \n    def _format_date(self, date_str: str) -> str:\n        \"\"\"Format date for Tally (YYYYMMDD).\"\"\"\n        if not date_str:\n            return datetime.now().strftime(\"%Y%m%d\")\n        \n        try:\n            # Try common date formats\n            for fmt in [\"%Y-%m-%d\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%Y/%m/%d\", \"%d.%m.%Y\"]:\n                try:\n                    dt = datetime.strptime(date_str, fmt)\n                    return dt.strftime(\"%Y%m%d\")\n                except ValueError:\n                    continue\n            \n            logger.warning(f\"Could not parse date: {date_str}, using current date\")\n            return datetime.now().strftime(\"%Y%m%d\")\n            \n        except Exception as e:\n            logger.error(f\"Error formatting date {date_str}: {e}\")\n            return datetime.now().strftime(\"%Y%m%d\")\n    \n    def _prettify_xml(self, element: ET.Element) -> str:\n        \"\"\"Convert XML element to prettified string.\"\"\"\n        xml_str = ET.tostring(element, encoding='unicode')\n        xml_declaration = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n'\n        \n        # Basic prettification\n        lines = xml_str.split('>')\n        formatted_lines = []\n        indent_level = 0\n        \n        for line in lines:\n            line = line.strip()\n            if not line:\n                continue\n                \n            if line.startswith('</'):\n                indent_level -= 1\n            \n            formatted_lines.append('  ' * indent_level + line + '>')\n            \n            if not line.startswith('</') and not line.endswith('/>') and '</' not in line:\n                indent_level += 1\n        \n        formatted_xml = xml_declaration + '\\n'.join(formatted_lines)\n        return formatted_xml.replace('>>', '>')","size_bytes":16753},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"google-genai>=1.38.0\",\n    \"pandas>=2.3.2\",\n    \"pdf2image>=1.17.0\",\n    \"pillow>=11.3.0\",\n    \"poppler-utils>=0.1.0\",\n    \"pydantic>=2.11.9\",\n    \"sift-stack-py>=0.9.1\",\n    \"streamlit>=1.49.1\",\n]\n","size_bytes":345},"replit.md":{"content":"# Bank Statement Transaction Extractor\n\n## Overview\n\nThis is a Streamlit-based web application that uses AI to extract transaction data from bank statement images and generate Tally-compatible XML files for accounting software integration. The application leverages Google's Gemini AI to perform optical character recognition and structured data extraction from PNG bank statement images, then formats the extracted transactions into XML that can be imported directly into Tally accounting software.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Frontend Architecture\n- **Framework**: Streamlit web framework for rapid prototyping and deployment\n- **User Interface**: Simple form-based interface with file upload capabilities\n- **Layout**: Wide layout configuration with columnar organization for configuration inputs\n- **Caching**: Streamlit's `@st.cache_resource` decorator for efficient resource management\n\n### Backend Architecture\n- **Core Components**:\n  - `TransactionExtractor`: Handles AI-powered data extraction from images\n  - `TallyXMLGenerator`: Converts extracted data to Tally-compatible XML format\n- **Data Processing Pipeline**:\n  1. Image upload and validation (PNG format)\n  2. AI-powered transaction extraction using Gemini\n  3. Data structuring using Pydantic models\n  4. XML generation for Tally import\n- **Error Handling**: Environment variable validation and user-friendly error messages\n\n### Data Models\n- **Transaction Schema**: Pydantic model with fields for date, narration, debit/credit amounts, and running balance\n- **XML Structure**: Tally-specific envelope format with proper headers and data organization\n- **Configuration**: Company name and bank ledger mapping for Tally integration\n\n### AI Integration\n- **Provider**: Google Gemini AI for optical character recognition and data extraction\n- **Input Processing**: Accepts PNG image format for bank statements\n- **Output Formatting**: Structured JSON extraction with specific field mapping\n- **Prompt Engineering**: Specialized prompts for financial document processing\n\n## External Dependencies\n\n### AI Services\n- **Google Gemini API**: Primary AI service for image analysis and text extraction\n  - Requires `GEMINI_API_KEY` environment variable\n  - Used for OCR and structured data extraction from bank statement images\n\n### Python Libraries\n- **Streamlit**: Web application framework for user interface\n- **Pydantic**: Data validation and modeling for transaction structures\n- **PIL (Pillow)**: Image processing and manipulation\n- **xml.etree.ElementTree**: XML generation for Tally import format\n\n### Accounting Software Integration\n- **Tally**: Target accounting software for XML import\n  - Requires company name configuration\n  - Requires bank ledger name mapping\n  - Uses suspense ledger for unmatched transactions","size_bytes":2869},"tally_xml_generator.py":{"content":"import xml.etree.ElementTree as ET\nfrom typing import List, Dict, Any\nfrom datetime import datetime\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass TallyXMLGenerator:\n    def __init__(self, company_name: str, bank_ledger_name: str):\n        \"\"\"\n        Initialize Tally XML generator.\n\n        Args:\n            company_name: Name of the company in Tally\n            bank_ledger_name: Name of the bank ledger in Tally\n        \"\"\"\n        self.company_name = company_name\n        self.bank_ledger_name = bank_ledger_name\n        self.suspense_ledger_name = \"Suspense\"\n\n    def generate_xml(self, transactions: List[Dict[str, Any]]) -> str:\n        \"\"\"\n        Generate Tally XML for bank transactions.\n\n        Args:\n            transactions: List of transaction dictionaries\n\n        Returns:\n            XML string ready for Tally import\n        \"\"\"\n        # Create root envelope\n        envelope = ET.Element(\"ENVELOPE\")\n\n        # Header\n        header = ET.SubElement(envelope, \"HEADER\")\n        ET.SubElement(header, \"TALLYREQUEST\").text = \"Import Data\"\n        ET.SubElement(header, \"TYPE\").text = \"Data\"\n        ET.SubElement(header, \"ID\").text = \"Vouchers\"\n\n        # Body\n        body = ET.SubElement(envelope, \"BODY\")\n        import_data = ET.SubElement(body, \"IMPORTDATA\")\n\n        # Request description\n        request_desc = ET.SubElement(import_data, \"REQUESTDESC\")\n        ET.SubElement(request_desc, \"REPORTNAME\").text = \"Vouchers\"\n        static_vars = ET.SubElement(request_desc, \"STATICVARIABLES\")\n        ET.SubElement(static_vars, \"SVCURRENTCOMPANY\").text = self.company_name\n\n        # Request data\n        request_data = ET.SubElement(import_data, \"REQUESTDATA\")\n\n        # Create Suspense ledger if it doesn't exist\n        self._add_suspense_ledger(request_data)\n\n        # Add transactions as vouchers\n        voucher_number = 1\n        for transaction in transactions:\n            self._add_transaction_voucher(request_data, transaction, voucher_number)\n            voucher_number += 1\n\n        # Convert to string with proper formatting\n        return self._prettify_xml(envelope)\n\n    def _add_suspense_ledger(self, parent: ET.Element):\n        \"\"\"Add Suspense ledger creation to XML.\"\"\"\n        tally_message = ET.SubElement(parent, \"TALLYMESSAGE\")\n        tally_message.set(\"xmlns:UDF\", \"TallyUDF\")\n\n        ledger = ET.SubElement(tally_message, \"LEDGER\")\n        ledger.set(\"NAME\", self.suspense_ledger_name)\n        ledger.set(\"ACTION\", \"Create\")\n\n        ET.SubElement(ledger, \"PARENT\").text = \"Suspense A/c\"\n        ET.SubElement(ledger, \"ISBILLWISEON\").text = \"No\"\n        ET.SubElement(ledger, \"ISCOSTCENTRESON\").text = \"No\"\n\n    def _add_transaction_voucher(self, parent: ET.Element, transaction: Dict[str, Any], voucher_number: int):\n        \"\"\"Add a single transaction as a voucher.\"\"\"\n        tally_message = ET.SubElement(parent, \"TALLYMESSAGE\")\n        tally_message.set(\"xmlns:UDF\", \"TallyUDF\")\n        \n        # Determine voucher type and amounts\n        debit_amount = self._parse_amount(transaction.get('debit_amount'))\n        credit_amount = self._parse_amount(transaction.get('credit_amount'))\n        \n        if credit_amount > 0:\n            # Money came into bank (Receipt) - Debit bank account\n            voucher_type = \"Receipt\"\n            transaction_amount = credit_amount\n            bank_is_debit = True  # Money coming in = debit bank\n        elif debit_amount > 0:\n            # Money went out of bank (Payment) - Credit bank account  \n            voucher_type = \"Payment\"\n            transaction_amount = debit_amount\n            bank_is_debit = False  # Money going out = credit bank\n        else:\n            # Skip transactions with no amount\n            return\n        \n        voucher = ET.SubElement(tally_message, \"VOUCHER\")\n        voucher.set(\"VCHTYPE\", voucher_type)\n        voucher.set(\"ACTION\", \"Create\")\n        \n        # Voucher details\n        transaction_date = self._format_date(transaction.get('date', ''))\n        ET.SubElement(voucher, \"DATE\").text = transaction_date\n        ET.SubElement(voucher, \"VOUCHERTYPENAME\").text = voucher_type\n        ET.SubElement(voucher, \"VOUCHERNUMBER\").text = str(voucher_number)\n        ET.SubElement(voucher, \"NARRATION\").text = transaction.get('narration', '')[:250]  # Limit length\n        \n        # Bank ledger entry\n        bank_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n        ET.SubElement(bank_entry, \"LEDGERNAME\").text = self.bank_ledger_name\n        if bank_is_debit:\n            # Receipt: Bank is debited (money coming in)\n            ET.SubElement(bank_entry, \"ISDEEMEDPOSITIVE\").text = \"No\"\n            ET.SubElement(bank_entry, \"AMOUNT\").text = f\"{transaction_amount:.2f}\"\n        else:\n            # Payment: Bank is credited (money going out)\n            ET.SubElement(bank_entry, \"ISDEEMEDPOSITIVE\").text = \"Yes\"\n            ET.SubElement(bank_entry, \"AMOUNT\").text = f\"-{transaction_amount:.2f}\"\n        \n        # Suspense ledger entry (opposite of bank)\n        suspense_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n        ET.SubElement(suspense_entry, \"LEDGERNAME\").text = self.suspense_ledger_name\n        if bank_is_debit:\n            # Receipt: Suspense is credited (source of money)\n            ET.SubElement(suspense_entry, \"ISDEEMEDPOSITIVE\").text = \"Yes\"\n            ET.SubElement(suspense_entry, \"AMOUNT\").text = f\"-{transaction_amount:.2f}\"\n        else:\n            # Payment: Suspense is debited (destination of money)\n            ET.SubElement(suspense_entry, \"ISDEEMEDPOSITIVE\").text = \"No\"\n            ET.SubElement(suspense_entry, \"AMOUNT\").text = f\"{transaction_amount:.2f}\"\n        \n    \n\n\n            \n\n    def _parse_amount(self, amount_str: Any) -> float:\n        \"\"\"Parse amount string to float.\"\"\"\n        if not amount_str:\n            return 0.0\n        try:\n            # Remove currency symbols and commas\n            amount_str = str(amount_str).replace(\"â‚¹\", \"\").replace(\",\", \"\").strip()\n            return float(amount_str) if amount_str else 0.0\n        except (ValueError, TypeError):\n            return 0.0\n\n    def _format_date(self, date_str: str) -> str:\n        \"\"\"Format date for Tally (YYYYMMDD).\"\"\"\n        if not date_str:\n            return datetime.now().strftime(\"%Y%m%d\")\n\n        try:\n            # Try common date formats\n            for fmt in [\"%Y-%m-%d\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%Y/%m/%d\", \"%d.%m.%Y\"]:\n                try:\n                    dt = datetime.strptime(date_str, fmt)\n                    return dt.strftime(\"%Y%m%d\")\n                except ValueError:\n                    continue\n\n            # If parsing fails, use current date\n            logger.warning(f\"Could not parse date: {date_str}, using current date\")\n            return datetime.now().strftime(\"%Y%m%d\")\n\n        except Exception as e:\n            logger.error(f\"Error formatting date {date_str}: {e}\")\n            return datetime.now().strftime(\"%Y%m%d\")\n\n    def _prettify_xml(self, element: ET.Element) -> str:\n        \"\"\"Convert XML element to prettified string.\"\"\"\n        # Create XML declaration and format\n        xml_str = ET.tostring(element, encoding=\"unicode\")\n\n        # Add XML declaration\n        xml_declaration = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n'\n\n        # Basic prettification (simple indentation)\n        lines = xml_str.split(\">\")\n        formatted_lines = []\n        indent_level = 0\n\n        for line in lines:\n            line = line.strip()\n            if not line:\n                continue\n\n            if line.startswith(\"</\"):\n                indent_level -= 1\n\n            formatted_lines.append(\"  \" * indent_level + line + \">\")\n\n            if (\n                not line.startswith(\"</\")\n                and not line.endswith(\"/>\")\n                and not any(\n                    line.startswith(f\"<{tag}\") and f\"</{tag}>\" in line\n                    for tag in [\n                        \"TALLYREQUEST\",\n                        \"TYPE\",\n                        \"ID\",\n                        \"REPORTNAME\",\n                        \"SVCURRENTCOMPANY\",\n                        \"PARENT\",\n                        \"ISBILLWISEON\",\n                        \"ISCOSTCENTRESON\",\n                        \"DATE\",\n                        \"VOUCHERTYPENAME\",\n                        \"VOUCHERNUMBER\",\n                        \"NARRATION\",\n                        \"LEDGERNAME\",\n                        \"ISDEEMEDPOSITIVE\",\n                        \"AMOUNT\",\n                    ]\n                )\n            ):\n                indent_level += 1\n\n        formatted_xml = xml_declaration + \"\\n\".join(formatted_lines)\n\n        # Remove the extra > at the end\n        formatted_xml = formatted_xml.replace(\">>\", \">\")\n\n        return formatted_xml\n\n    def validate_xml_structure(\n        self, transactions: List[Dict[str, Any]]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Validate transaction data before XML generation.\n\n        Returns:\n            Dictionary with validation results\n        \"\"\"\n        validation_result = {\n            \"valid\": True,\n            \"errors\": [],\n            \"warnings\": [],\n            \"transaction_count\": len(transactions),\n        }\n\n        if not transactions:\n            validation_result[\"valid\"] = False\n            validation_result[\"errors\"].append(\"No transactions provided\")\n            return validation_result\n\n        if not self.company_name.strip():\n            validation_result[\"valid\"] = False\n            validation_result[\"errors\"].append(\"Company name is required\")\n\n        if not self.bank_ledger_name.strip():\n            validation_result[\"valid\"] = False\n            validation_result[\"errors\"].append(\"Bank ledger name is required\")\n\n        # Validate individual transactions\n        for i, transaction in enumerate(transactions):\n            if not transaction.get(\"narration\"):\n                validation_result[\"warnings\"].append(\n                    f\"Transaction {i+1}: Missing narration\"\n                )\n\n            debit = self._parse_amount(transaction.get(\"debit_amount\"))\n            credit = self._parse_amount(transaction.get(\"credit_amount\"))\n\n            if debit == 0 and credit == 0:\n                validation_result[\"warnings\"].append(\n                    f\"Transaction {i+1}: No amount specified\"\n                )\n\n            if debit > 0 and credit > 0:\n                validation_result[\"warnings\"].append(\n                    f\"Transaction {i+1}: Both debit and credit amounts present\"\n                )\n\n        return validation_result\n","size_bytes":10562},"transaction_extractor.py":{"content":"import json\nimport logging\nimport os\nfrom typing import List, Dict, Any, Optional\n\nfrom google import genai\nfrom google.genai import types\nfrom pydantic import BaseModel\nfrom PIL import Image\nimport io\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nclass Transaction(BaseModel):\n    date: str\n    narration: str\n    debit_amount: Optional[str] = None\n    credit_amount: Optional[str] = None\n    running_balance: str\n\nclass TransactionExtractor:\n    def __init__(self):\n        \"\"\"Initialize the transaction extractor with Gemini client.\"\"\"\n        api_key = os.environ.get(\"GEMINI_API_KEY\")\n        if not api_key:\n            raise ValueError(\"GEMINI_API_KEY environment variable is required\")\n        \n        self.client = genai.Client(api_key=api_key)\n        \n    def extract_transactions(self, image_bytes: bytes) -> List[Dict[str, Any]]:\n        \"\"\"\n        Extract transaction data from bank statement image.\n        \n        Args:\n            image_bytes: PNG image data as bytes\n            \n        Returns:\n            List of transaction dictionaries\n        \"\"\"\n        try:\n            # Streamlined prompt for faster processing\n            prompt = \"\"\"Extract all transactions from this bank statement as JSON array.\n\nRequired fields per transaction:\n- date: Transaction date (YYYY-MM-DD preferred)\n- narration: Description/details \n- debit_amount: Debit amount (number only, null if none)\n- credit_amount: Credit amount (number only, null if none)\n- running_balance: Balance after transaction (number only)\n\nReturn only valid JSON array. Include all visible transactions in chronological order , and make sure to follow the accounting convention , if something is withrawal in the bank so it should be credit and if it is deposit then it must be debit\"\"\"\n\n            # Optimize image before processing\n            optimized_image_bytes = self._optimize_image(image_bytes)\n            \n            # Generate content with image analysis using faster model\n            response = self.client.models.generate_content(\n                model=\"gemini-2.5-flash\",\n                contents=[\n                    types.Part.from_bytes(\n                        data=optimized_image_bytes,\n                        mime_type=\"image/png\",\n                    ),\n                    prompt\n                ],\n                config=types.GenerateContentConfig(\n                    response_mime_type=\"application/json\",\n                ),\n            )\n\n            if not response.text:\n                logger.error(\"Empty response from Gemini API\")\n                return []\n\n            # Parse the JSON response\n            try:\n                transactions_data = json.loads(response.text)\n                \n                # Validate and clean the data\n                if isinstance(transactions_data, list):\n                    cleaned_transactions = []\n                    for transaction in transactions_data:\n                        if isinstance(transaction, dict):\n                            cleaned_transaction = self._clean_transaction_data(transaction)\n                            if cleaned_transaction:\n                                cleaned_transactions.append(cleaned_transaction)\n                    \n                    logger.info(f\"Successfully extracted {len(cleaned_transactions)} transactions\")\n                    return cleaned_transactions\n                else:\n                    logger.error(\"Response is not a list of transactions\")\n                    return []\n                    \n            except json.JSONDecodeError as e:\n                logger.error(f\"Failed to parse JSON response: {e}\")\n                logger.error(f\"Raw response: {response.text}\")\n                return []\n\n        except Exception as e:\n            logger.error(f\"Error extracting transactions: {e}\")\n            raise Exception(f\"Failed to extract transactions: {str(e)}\")\n\n    def _clean_transaction_data(self, transaction: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Clean and validate transaction data.\n        \n        Args:\n            transaction: Raw transaction dictionary\n            \n        Returns:\n            Cleaned transaction dictionary or None if invalid\n        \"\"\"\n        try:\n            # Required fields\n            date = str(transaction.get('date', '')).strip()\n            narration = str(transaction.get('narration', '')).strip()\n            running_balance = str(transaction.get('running_balance', '')).strip()\n            \n            # Optional amount fields\n            debit_amount = transaction.get('debit_amount')\n            credit_amount = transaction.get('credit_amount')\n            \n            # Skip if essential fields are missing\n            if not date or not narration:\n                logger.warning(f\"Skipping transaction with missing essential fields: {transaction}\")\n                return None\n            \n            # Clean amount fields\n            cleaned_debit = self._clean_amount(debit_amount)\n            cleaned_credit = self._clean_amount(credit_amount)\n            cleaned_balance = self._clean_amount(running_balance)\n            \n            cleaned_transaction = {\n                'date': date,\n                'narration': narration,\n                'debit_amount': cleaned_debit,\n                'credit_amount': cleaned_credit,\n                'running_balance': cleaned_balance or '0'\n            }\n            \n            return cleaned_transaction\n            \n        except Exception as e:\n            logger.error(f\"Error cleaning transaction data: {e}\")\n            return None\n\n    def _clean_amount(self, amount: Any) -> Optional[str]:\n        \"\"\"\n        Clean and validate amount field.\n        \n        Args:\n            amount: Raw amount value\n            \n        Returns:\n            Cleaned amount string or None\n        \"\"\"\n        if amount is None or amount == '':\n            return None\n            \n        # Convert to string and clean\n        amount_str = str(amount).strip()\n        \n        # Remove common currency symbols and formatting\n        amount_str = amount_str.replace('â‚¹', '').replace('$', '').replace(',', '').strip()\n        \n        # Handle empty or null values\n        if not amount_str or amount_str.lower() in ['null', 'none', '-', '']:\n            return None\n            \n        try:\n            # Validate that it's a valid number\n            float(amount_str)\n            return amount_str\n        except ValueError:\n            logger.warning(f\"Invalid amount format: {amount}\")\n            return None\n\n    def extract_transactions_with_retry(self, image_bytes: bytes, max_retries: int = 2) -> List[Dict[str, Any]]:\n        \"\"\"\n        Extract transactions with retry logic.\n        \n        Args:\n            image_bytes: PNG image data as bytes\n            max_retries: Maximum number of retry attempts\n            \n        Returns:\n            List of transaction dictionaries\n        \"\"\"\n        for attempt in range(max_retries + 1):\n            try:\n                transactions = self.extract_transactions(image_bytes)\n                if transactions:  # If we got results, return them\n                    return transactions\n                elif attempt < max_retries:  # If no results but we have retries left\n                    logger.info(f\"No transactions found, retrying... (attempt {attempt + 1})\")\n                    continue\n                else:  # Final attempt with no results\n                    logger.warning(\"No transactions found after all retry attempts\")\n                    return []\n                    \n            except Exception as e:\n                if attempt < max_retries:\n                    logger.warning(f\"Attempt {attempt + 1} failed: {e}. Retrying...\")\n                    continue\n                else:\n                    logger.error(f\"All attempts failed. Final error: {e}\")\n                    raise e\n                    \n        return []\n\n    def _optimize_image(self, image_bytes: bytes) -> bytes:\n        \"\"\"\n        Optimize image for faster AI processing while maintaining accuracy.\n        \n        Args:\n            image_bytes: Original image bytes\n            \n        Returns:\n            Optimized image bytes\n        \"\"\"\n        try:\n            # Open the image\n            image = Image.open(io.BytesIO(image_bytes))\n            \n            # Convert to RGB if needed (for consistent processing)\n            if image.mode != 'RGB':\n                image = image.convert('RGB')\n            \n            # Get original dimensions\n            width, height = image.size\n            \n            # Calculate optimal size (max 2048px on longer side for good balance of speed/accuracy)\n            max_dimension = 2048\n            if max(width, height) > max_dimension:\n                if width > height:\n                    new_width = max_dimension\n                    new_height = int(height * (max_dimension / width))\n                else:\n                    new_height = max_dimension\n                    new_width = int(width * (max_dimension / height))\n                \n                # Resize with high-quality resampling\n                image = image.resize((new_width, new_height), Image.Resampling.LANCZOS)\n                logger.info(f\"Resized image from {width}x{height} to {new_width}x{new_height}\")\n            \n            # Save optimized image to bytes\n            output_bytes = io.BytesIO()\n            image.save(output_bytes, format='PNG', optimize=True)\n            return output_bytes.getvalue()\n            \n        except Exception as e:\n            logger.warning(f\"Image optimization failed: {e}. Using original image.\")\n            return image_bytes\n","size_bytes":9760},".streamlit/config.toml":{"content":"[server]\nheadless = true\naddress = \"0.0.0.0\"\nport = 5000\n\n[browser]\ngatherUsageStats = false\n","size_bytes":93},"gstr2b_dedicated_processor.py":{"content":"import json\nimport logging\nfrom typing import List, Dict, Any, Optional, Tuple\nfrom datetime import datetime\nfrom dataclasses import dataclass\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass GSTR2BVendor:\n    \"\"\"Represents a vendor from GSTR2B data.\"\"\"\n    ctin: str\n    trdnm: str\n    total_invoices: int\n    total_taxable_value: float\n    total_cgst: float\n    total_sgst: float\n    total_igst: float\n    total_cess: float\n    invoices: List[Dict[str, Any]]\n\n@dataclass \nclass GSTR2BInvoice:\n    \"\"\"Represents an invoice from GSTR2B data.\"\"\"\n    vendor_ctin: str\n    vendor_name: str\n    invoice_number: str\n    invoice_date: str\n    invoice_value: float\n    taxable_value: float\n    cgst_amount: float\n    sgst_amount: float\n    igst_amount: float\n    cess_amount: float\n    itc_available: str\n    reverse_charge: str\n    pos: str\n\nclass GSTR2BDedicatedProcessor:\n    \"\"\"Dedicated processor for official GSTR2B JSON files from GST portal.\"\"\"\n    \n    def __init__(self, company_state: str):\n        \"\"\"Initialize GSTR2B processor.\"\"\"\n        self.company_state = company_state\n        \n        # State code mapping for interstate determination\n        self.state_codes = {\n            \"Andhra Pradesh\": \"28\", \"Arunachal Pradesh\": \"12\", \"Assam\": \"18\", \"Bihar\": \"10\",\n            \"Chhattisgarh\": \"22\", \"Goa\": \"30\", \"Gujarat\": \"24\", \"Haryana\": \"06\", \n            \"Himachal Pradesh\": \"02\", \"Jharkhand\": \"20\", \"Karnataka\": \"29\", \"Kerala\": \"32\",\n            \"Madhya Pradesh\": \"23\", \"Maharashtra\": \"27\", \"Manipur\": \"14\", \"Meghalaya\": \"17\",\n            \"Mizoram\": \"15\", \"Nagaland\": \"13\", \"Odisha\": \"21\", \"Punjab\": \"03\", \"Rajasthan\": \"08\",\n            \"Sikkim\": \"11\", \"Tamil Nadu\": \"33\", \"Telangana\": \"36\", \"Tripura\": \"16\",\n            \"Uttar Pradesh\": \"09\", \"Uttarakhand\": \"05\", \"West Bengal\": \"19\", \"Delhi\": \"07\",\n            \"Puducherry\": \"34\", \"Andaman and Nicobar Islands\": \"35\", \"Chandigarh\": \"04\",\n            \"Dadra and Nagar Haveli\": \"26\", \"Daman and Diu\": \"25\", \"Jammu and Kashmir\": \"01\",\n            \"Ladakh\": \"02\", \"Lakshadweep\": \"31\"\n        }\n    \n    def process_gstr2b_json(self, gstr2b_json: Dict[str, Any]) -> Tuple[List[GSTR2BVendor], List[GSTR2BInvoice], Dict[str, Any]]:\n        \"\"\"\n        Process official GSTR2B JSON and extract vendors and invoices.\n        \n        Args:\n            gstr2b_json: Official GSTR2B JSON from GST portal\n            \n        Returns:\n            Tuple of (vendors_list, invoices_list, metadata)\n        \"\"\"\n        try:\n            # Extract metadata\n            data = gstr2b_json.get('data', {})\n            metadata = {\n                'gstin': data.get('gstin', ''),\n                'return_period': data.get('rtnprd', ''),\n                'generated_date': data.get('gendt', ''),\n                'version': data.get('version', ''),\n                'checksum': gstr2b_json.get('chksum', '')\n            }\n            \n            logger.info(f\"Processing GSTR2B for GSTIN: {metadata['gstin']}, Period: {metadata['return_period']}\")\n            \n            # Process B2B invoices from docdata\n            vendors = []\n            all_invoices = []\n            \n            docdata = data.get('docdata', {})\n            b2b_data = docdata.get('b2b', [])\n            \n            for vendor_data in b2b_data:\n                vendor = self._process_vendor(vendor_data)\n                vendors.append(vendor)\n                \n                # Process each invoice for this vendor\n                for invoice_data in vendor_data.get('inv', []):\n                    invoice = self._process_invoice(vendor_data, invoice_data)\n                    all_invoices.append(invoice)\n            \n            logger.info(f\"Processed {len(vendors)} vendors with {len(all_invoices)} total invoices\")\n            return vendors, all_invoices, metadata\n            \n        except Exception as e:\n            logger.error(f\"Error processing GSTR2B JSON: {e}\")\n            return [], [], {}\n    \n    def _process_vendor(self, vendor_data: Dict[str, Any]) -> GSTR2BVendor:\n        \"\"\"Process vendor data from GSTR2B.\"\"\"\n        ctin = vendor_data.get('ctin', '')\n        trdnm = vendor_data.get('trdnm', '')\n        invoices = vendor_data.get('inv', [])\n        \n        # Calculate totals from invoices\n        total_taxable = sum(float(inv.get('txval', 0)) for inv in invoices)\n        total_cgst = sum(float(inv.get('cgst', 0)) for inv in invoices)\n        total_sgst = sum(float(inv.get('sgst', 0)) for inv in invoices)\n        total_igst = sum(float(inv.get('igst', 0)) for inv in invoices)\n        total_cess = sum(float(inv.get('cess', 0)) for inv in invoices)\n        \n        return GSTR2BVendor(\n            ctin=ctin,\n            trdnm=trdnm,\n            total_invoices=len(invoices),\n            total_taxable_value=total_taxable,\n            total_cgst=total_cgst,\n            total_sgst=total_sgst,\n            total_igst=total_igst,\n            total_cess=total_cess,\n            invoices=invoices\n        )\n    \n    def _process_invoice(self, vendor_data: Dict[str, Any], invoice_data: Dict[str, Any]) -> GSTR2BInvoice:\n        \"\"\"Process individual invoice data.\"\"\"\n        vendor_ctin = vendor_data.get('ctin', '')\n        vendor_name = vendor_data.get('trdnm', '')\n        \n        return GSTR2BInvoice(\n            vendor_ctin=vendor_ctin,\n            vendor_name=vendor_name,\n            invoice_number=invoice_data.get('inum', ''),\n            invoice_date=self._format_date(invoice_data.get('dt', '')),\n            invoice_value=float(invoice_data.get('val', 0)),\n            taxable_value=float(invoice_data.get('txval', 0)),\n            cgst_amount=float(invoice_data.get('cgst', 0)),\n            sgst_amount=float(invoice_data.get('sgst', 0)),\n            igst_amount=float(invoice_data.get('igst', 0)),\n            cess_amount=float(invoice_data.get('cess', 0)),\n            itc_available=invoice_data.get('itcavl', 'Y'),\n            reverse_charge=invoice_data.get('rev', 'N'),\n            pos=invoice_data.get('pos', '')\n        )\n    \n    def _format_date(self, date_str: str) -> str:\n        \"\"\"Format GST date string.\"\"\"\n        if not date_str:\n            return datetime.now().strftime(\"%Y-%m-%d\")\n        \n        try:\n            # GSTR2B dates are in DD-MM-YYYY format\n            if '-' in date_str and len(date_str.split('-')) == 3:\n                day, month, year = date_str.split('-')\n                dt = datetime(int(year), int(month), int(day))\n                return dt.strftime(\"%Y-%m-%d\")\n            else:\n                return datetime.now().strftime(\"%Y-%m-%d\")\n        except Exception as e:\n            logger.error(f\"Error formatting date {date_str}: {e}\")\n            return datetime.now().strftime(\"%Y-%m-%d\")\n    \n    def get_vendor_summary(self, vendors: List[GSTR2BVendor]) -> Dict[str, Any]:\n        \"\"\"Get summary statistics for vendors.\"\"\"\n        if not vendors:\n            return {}\n        \n        total_vendors = len(vendors)\n        total_invoices = sum(v.total_invoices for v in vendors)\n        total_taxable_value = sum(v.total_taxable_value for v in vendors)\n        total_tax_amount = sum(v.total_cgst + v.total_sgst + v.total_igst for v in vendors)\n        \n        return {\n            'total_vendors': total_vendors,\n            'total_invoices': total_invoices,\n            'total_taxable_value': total_taxable_value,\n            'total_tax_amount': total_tax_amount,\n            'total_invoice_value': total_taxable_value + total_tax_amount\n        }\n    \n    def validate_gstr2b_data(self, gstr2b_json: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Validate GSTR2B JSON structure.\"\"\"\n        validation_result = {\n            'valid': True,\n            'errors': [],\n            'warnings': []\n        }\n        \n        # Check basic structure\n        if 'data' not in gstr2b_json:\n            validation_result['valid'] = False\n            validation_result['errors'].append(\"Missing 'data' section in GSTR2B JSON\")\n            return validation_result\n        \n        data = gstr2b_json['data']\n        \n        # Check required fields\n        required_fields = ['gstin', 'rtnprd', 'docdata']\n        for field in required_fields:\n            if field not in data:\n                validation_result['valid'] = False\n                validation_result['errors'].append(f\"Missing required field: {field}\")\n        \n        # Check docdata structure\n        if 'docdata' in data:\n            docdata = data['docdata']\n            if 'b2b' not in docdata:\n                validation_result['warnings'].append(\"No B2B data found in docdata\")\n            elif not docdata['b2b']:\n                validation_result['warnings'].append(\"Empty B2B data found\")\n        \n        # Check for invoices\n        total_invoices = 0\n        if 'docdata' in data and 'b2b' in data['docdata']:\n            for vendor in data['docdata']['b2b']:\n                total_invoices += len(vendor.get('inv', []))\n        \n        if total_invoices == 0:\n            validation_result['warnings'].append(\"No invoices found in GSTR2B data\")\n        else:\n            validation_result['warnings'].append(f\"Found {total_invoices} invoices for processing\")\n        \n        return validation_result","size_bytes":9193},"gstr2b_masters_xml.py":{"content":"import xml.etree.ElementTree as ET\nfrom typing import List, Dict, Any\nfrom datetime import datetime\nimport logging\nfrom gstr2b_dedicated_processor import GSTR2BVendor\n\nlogger = logging.getLogger(__name__)\n\nclass GSTR2BMastersXMLGenerator:\n    \"\"\"Generate Masters XML for GSTR2B vendor ledgers to import into Tally.\"\"\"\n    \n    def __init__(self, company_name: str, company_state: str):\n        \"\"\"\n        Initialize GSTR2B Masters XML generator.\n        \n        Args:\n            company_name: Name of the company in Tally\n            company_state: Company's state for GST ledger creation\n        \"\"\"\n        self.company_name = company_name\n        self.company_state = company_state\n    \n    def generate_masters_xml(self, vendors: List[GSTR2BVendor], metadata: Dict[str, Any]) -> str:\n        \"\"\"\n        Generate Masters XML containing all vendor ledgers and GST tax ledgers.\n        \n        Args:\n            vendors: List of GSTR2BVendor objects\n            metadata: GSTR2B metadata\n            \n        Returns:\n            XML string for Tally import\n        \"\"\"\n        try:\n            # Create root envelope\n            envelope = ET.Element(\"ENVELOPE\")\n            \n            # Header\n            header = ET.SubElement(envelope, \"HEADER\")\n            ET.SubElement(header, \"TALLYREQUEST\").text = \"Import Data\"\n            ET.SubElement(header, \"TYPE\").text = \"Data\"\n            ET.SubElement(header, \"ID\").text = \"All Masters\"\n            \n            # Body\n            body = ET.SubElement(envelope, \"BODY\")\n            import_data = ET.SubElement(body, \"IMPORTDATA\")\n            \n            # Request description\n            request_desc = ET.SubElement(import_data, \"REQUESTDESC\")\n            ET.SubElement(request_desc, \"REPORTNAME\").text = \"All Masters\"\n            static_vars = ET.SubElement(request_desc, \"STATICVARIABLES\")\n            ET.SubElement(static_vars, \"SVCURRENTCOMPANY\").text = self.company_name\n            \n            # Request data\n            request_data = ET.SubElement(import_data, \"REQUESTDATA\")\n            \n            # Create groups first\n            self._create_ledger_groups(request_data)\n            \n            # Create GST tax ledgers\n            self._create_gst_tax_ledgers(request_data, vendors)\n            \n            # Create vendor ledgers\n            self._create_vendor_ledgers(request_data, vendors)\n            \n            # Create purchase ledgers\n            self._create_purchase_ledgers(request_data)\n            \n            return self._prettify_xml(envelope)\n            \n        except Exception as e:\n            logger.error(f\"Error generating GSTR2B Masters XML: {e}\")\n            return \"\"\n    \n    def _create_ledger_groups(self, parent: ET.Element):\n        \"\"\"Create required ledger groups.\"\"\"\n        # Sundry Creditors group (if needed)\n        self._create_group(parent, \"GSTR2B Suppliers\", \"Sundry Creditors\")\n        \n        # GST tax groups\n        self._create_group(parent, \"GST Input Tax\", \"Duties & Taxes\")\n        \n        # Purchase groups\n        self._create_group(parent, \"GSTR2B Purchases\", \"Purchase Accounts\")\n    \n    def _create_group(self, parent: ET.Element, group_name: str, under_group: str):\n        \"\"\"Create a ledger group.\"\"\"\n        msg = ET.SubElement(parent, \"TALLYMESSAGE\")\n        msg.set(\"xmlns:UDF\", \"TallyUDF\")\n        group = ET.SubElement(msg, \"GROUP\")\n        group.set(\"NAME\", group_name)\n        group.set(\"ACTION\", \"Create\")\n        ET.SubElement(group, \"PARENT\").text = under_group\n        ET.SubElement(group, \"ISSUBLEDGER\").text = \"No\"\n    \n    def _create_gst_tax_ledgers(self, parent: ET.Element, vendors: List[GSTR2BVendor]):\n        \"\"\"Create GST input tax ledgers based on data.\"\"\"\n        tax_rates = set()\n        \n        # Collect all tax rates from vendor data\n        for vendor in vendors:\n            for invoice in vendor.invoices:\n                txval = float(invoice.get('txval', 0))\n                cgst = float(invoice.get('cgst', 0))\n                sgst = float(invoice.get('sgst', 0))\n                igst = float(invoice.get('igst', 0))\n                \n                # Calculate rates\n                if txval > 0:\n                    if cgst > 0:\n                        cgst_rate = round((cgst / txval) * 100)\n                        tax_rates.add(cgst_rate)\n                    if sgst > 0:\n                        sgst_rate = round((sgst / txval) * 100)\n                        tax_rates.add(sgst_rate)\n                    if igst > 0:\n                        igst_rate = round((igst / txval) * 100)\n                        tax_rates.add(igst_rate)\n        \n        # Create tax ledgers for each rate found\n        for rate in sorted(tax_rates):\n            if rate > 0:\n                # Input CGST\n                self._create_tax_ledger(parent, f\"Input CGST {rate}%\", \"GST Input Tax\")\n                # Input SGST\n                self._create_tax_ledger(parent, f\"Input SGST {rate}%\", \"GST Input Tax\")\n                # Input IGST (rate is usually double for IGST)\n                self._create_tax_ledger(parent, f\"Input IGST {rate * 2}%\", \"GST Input Tax\")\n        \n        # Create common tax ledgers that might be needed\n        common_rates = [2.5, 6, 9, 14, 18, 28]\n        for rate in common_rates:\n            self._create_tax_ledger(parent, f\"Input CGST {rate}%\", \"GST Input Tax\")\n            self._create_tax_ledger(parent, f\"Input SGST {rate}%\", \"GST Input Tax\")\n            self._create_tax_ledger(parent, f\"Input IGST {rate * 2}%\", \"GST Input Tax\")\n    \n    def _create_tax_ledger(self, parent: ET.Element, ledger_name: str, group_name: str):\n        \"\"\"Create a GST tax ledger.\"\"\"\n        msg = ET.SubElement(parent, \"TALLYMESSAGE\")\n        msg.set(\"xmlns:UDF\", \"TallyUDF\")\n        ledger = ET.SubElement(msg, \"LEDGER\")\n        ledger.set(\"NAME\", ledger_name)\n        ledger.set(\"ACTION\", \"Create\")\n        ET.SubElement(ledger, \"PARENT\").text = group_name\n        ET.SubElement(ledger, \"TAXCLASSIFICATIONNAME\").text = \"GST\"\n        ET.SubElement(ledger, \"TAXTYPE\").text = \"GST\"\n        ET.SubElement(ledger, \"GSTTYPE\").text = \"Input\"\n        ET.SubElement(ledger, \"APPROPRIATEFOR\").text = \"Both\"\n    \n    def _create_vendor_ledgers(self, parent: ET.Element, vendors: List[GSTR2BVendor]):\n        \"\"\"Create vendor ledgers for all suppliers.\"\"\"\n        for vendor in vendors:\n            vendor_name = self._clean_ledger_name(vendor.trdnm or f\"Vendor-{vendor.ctin}\")\n            \n            msg = ET.SubElement(parent, \"TALLYMESSAGE\")\n            msg.set(\"xmlns:UDF\", \"TallyUDF\")\n            ledger = ET.SubElement(msg, \"LEDGER\")\n            ledger.set(\"NAME\", vendor_name)\n            ledger.set(\"ACTION\", \"Create\")\n            \n            # Basic ledger details\n            ET.SubElement(ledger, \"PARENT\").text = \"GSTR2B Suppliers\"\n            ET.SubElement(ledger, \"ISBILLWISEON\").text = \"Yes\"\n            ET.SubElement(ledger, \"ISCOSTCENTRESON\").text = \"No\"\n            \n            # GST details\n            if vendor.ctin:\n                ET.SubElement(ledger, \"PARTYGSTIN\").text = vendor.ctin\n                ET.SubElement(ledger, \"GSTREGISTRATIONTYPE\").text = \"Regular\"\n                \n                # State from GSTIN (first 2 digits)\n                state_code = vendor.ctin[:2] if len(vendor.ctin) >= 2 else \"07\"\n                ET.SubElement(ledger, \"STATECODE\").text = state_code\n            \n            # Address (basic)\n            address = ET.SubElement(ledger, \"ADDRESS.LIST\")\n            ET.SubElement(address, \"ADDRESS\").text = f\"Supplier: {vendor.trdnm}\"\n            \n            # Opening balance (usually zero for new ledgers)\n            ET.SubElement(ledger, \"OPENINGBALANCE\").text = \"0.00\"\n    \n    def _create_purchase_ledgers(self, parent: ET.Element):\n        \"\"\"Create purchase ledgers for different categories.\"\"\"\n        purchase_categories = [\n            \"Purchase - Trading Goods\",\n            \"Purchase - Raw Materials\", \n            \"Purchase - Consumables\",\n            \"Purchase - Capital Goods\",\n            \"Purchase - Services\"\n        ]\n        \n        for category in purchase_categories:\n            msg = ET.SubElement(parent, \"TALLYMESSAGE\")\n            msg.set(\"xmlns:UDF\", \"TallyUDF\")\n            ledger = ET.SubElement(msg, \"LEDGER\")\n            ledger.set(\"NAME\", category)\n            ledger.set(\"ACTION\", \"Create\")\n            ET.SubElement(ledger, \"PARENT\").text = \"GSTR2B Purchases\"\n            ET.SubElement(ledger, \"ISCOSTCENTRESON\").text = \"No\"\n    \n    def _clean_ledger_name(self, name: str) -> str:\n        \"\"\"Clean and format ledger name for Tally.\"\"\"\n        if not name:\n            return \"Unknown Vendor\"\n        \n        # Remove special characters and limit length\n        cleaned = ''.join(c for c in name if c.isalnum() or c.isspace() or c in '-._')\n        return cleaned[:99].strip()  # Tally has ledger name limits\n    \n    def _prettify_xml(self, element: ET.Element) -> str:\n        \"\"\"Convert XML element to prettified string.\"\"\"\n        xml_str = ET.tostring(element, encoding='unicode')\n        xml_declaration = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n'\n        \n        # Basic prettification\n        lines = xml_str.split('>')\n        formatted_lines = []\n        indent_level = 0\n        \n        for line in lines:\n            line = line.strip()\n            if not line:\n                continue\n                \n            if line.startswith('</'):\n                indent_level -= 1\n            \n            formatted_lines.append('  ' * indent_level + line + '>')\n            \n            if not line.startswith('</') and not line.endswith('/>') and '</' not in line:\n                indent_level += 1\n        \n        formatted_xml = xml_declaration + '\\n'.join(formatted_lines)\n        return formatted_xml.replace('>>', '>')\n    \n    def validate_masters_xml(self, vendors: List[GSTR2BVendor]) -> Dict[str, Any]:\n        \"\"\"Validate masters data before XML generation.\"\"\"\n        validation_result = {\n            'valid': True,\n            'errors': [],\n            'warnings': []\n        }\n        \n        if not vendors:\n            validation_result['valid'] = False\n            validation_result['errors'].append(\"No vendors found for Masters XML generation\")\n            return validation_result\n        \n        # Check for duplicate vendor names\n        vendor_names = [self._clean_ledger_name(v.trdnm or f\"Vendor-{v.ctin}\") for v in vendors]\n        duplicates = set([name for name in vendor_names if vendor_names.count(name) > 1])\n        \n        if duplicates:\n            validation_result['warnings'].append(f\"Duplicate vendor names found: {list(duplicates)}\")\n        \n        # Check for vendors without GSTIN\n        vendors_without_gstin = [v for v in vendors if not v.ctin]\n        if vendors_without_gstin:\n            validation_result['warnings'].append(f\"{len(vendors_without_gstin)} vendors without GSTIN found\")\n        \n        validation_result['summary'] = {\n            'total_vendors': len(vendors),\n            'vendors_with_gstin': len([v for v in vendors if v.ctin]),\n            'total_invoices': sum(v.total_invoices for v in vendors)\n        }\n        \n        return validation_result","size_bytes":11200},"gstr2b_transactions_xml.py":{"content":"import xml.etree.ElementTree as ET\nfrom typing import List, Dict, Any\nfrom datetime import datetime\nimport logging\nfrom gstr2b_dedicated_processor import GSTR2BVendor, GSTR2BInvoice\n\nlogger = logging.getLogger(__name__)\n\nclass GSTR2BTransactionsXMLGenerator:\n    \"\"\"Generate Transactions XML for GSTR2B purchase vouchers to import into Tally.\"\"\"\n    \n    def __init__(self, company_name: str, company_state: str):\n        \"\"\"\n        Initialize GSTR2B Transactions XML generator.\n        \n        Args:\n            company_name: Name of the company in Tally\n            company_state: Company's state for interstate determination\n        \"\"\"\n        self.company_name = company_name\n        self.company_state = company_state\n        \n        # State code mapping\n        self.state_codes = {\n            \"07\": \"Delhi\", \"01\": \"Jammu and Kashmir\", \"02\": \"Himachal Pradesh\",\n            \"03\": \"Punjab\", \"04\": \"Chandigarh\", \"05\": \"Uttarakhand\", \"06\": \"Haryana\",\n            \"08\": \"Rajasthan\", \"09\": \"Uttar Pradesh\", \"10\": \"Bihar\", \"11\": \"Sikkim\",\n            \"12\": \"Arunachal Pradesh\", \"13\": \"Nagaland\", \"14\": \"Manipur\", \"15\": \"Mizoram\",\n            \"16\": \"Tripura\", \"17\": \"Meghalaya\", \"18\": \"Assam\", \"19\": \"West Bengal\",\n            \"20\": \"Jharkhand\", \"21\": \"Odisha\", \"22\": \"Chhattisgarh\", \"23\": \"Madhya Pradesh\",\n            \"24\": \"Gujarat\", \"25\": \"Daman and Diu\", \"26\": \"Dadra and Nagar Haveli\",\n            \"27\": \"Maharashtra\", \"28\": \"Andhra Pradesh\", \"29\": \"Karnataka\", \"30\": \"Goa\",\n            \"31\": \"Lakshadweep\", \"32\": \"Kerala\", \"33\": \"Tamil Nadu\", \"34\": \"Puducherry\",\n            \"35\": \"Andaman and Nicobar Islands\", \"36\": \"Telangana\"\n        }\n    \n    def generate_transactions_xml(self, invoices: List[GSTR2BInvoice], metadata: Dict[str, Any]) -> str:\n        \"\"\"\n        Generate Transactions XML containing all purchase vouchers.\n        \n        Args:\n            invoices: List of GSTR2BInvoice objects\n            metadata: GSTR2B metadata\n            \n        Returns:\n            XML string for Tally import\n        \"\"\"\n        try:\n            # Create root envelope\n            envelope = ET.Element(\"ENVELOPE\")\n            \n            # Header\n            header = ET.SubElement(envelope, \"HEADER\")\n            ET.SubElement(header, \"TALLYREQUEST\").text = \"Import Data\"\n            ET.SubElement(header, \"TYPE\").text = \"Data\"\n            ET.SubElement(header, \"ID\").text = \"Vouchers\"\n            \n            # Body\n            body = ET.SubElement(envelope, \"BODY\")\n            import_data = ET.SubElement(body, \"IMPORTDATA\")\n            \n            # Request description\n            request_desc = ET.SubElement(import_data, \"REQUESTDESC\")\n            ET.SubElement(request_desc, \"REPORTNAME\").text = \"Vouchers\"\n            static_vars = ET.SubElement(request_desc, \"STATICVARIABLES\")\n            ET.SubElement(static_vars, \"SVCURRENTCOMPANY\").text = self.company_name\n            \n            # Request data\n            request_data = ET.SubElement(import_data, \"REQUESTDATA\")\n            \n            # Create purchase vouchers for each invoice\n            voucher_number = 1\n            for invoice in invoices:\n                self._create_purchase_voucher(request_data, invoice, voucher_number)\n                voucher_number += 1\n            \n            return self._prettify_xml(envelope)\n            \n        except Exception as e:\n            logger.error(f\"Error generating GSTR2B Transactions XML: {e}\")\n            return \"\"\n    \n    def _create_purchase_voucher(self, parent: ET.Element, invoice: GSTR2BInvoice, voucher_number: int):\n        \"\"\"Create a purchase voucher for an invoice.\"\"\"\n        try:\n            msg = ET.SubElement(parent, \"TALLYMESSAGE\")\n            msg.set(\"xmlns:UDF\", \"TallyUDF\")\n            voucher = ET.SubElement(msg, \"VOUCHER\")\n            voucher.set(\"VCHTYPE\", \"Purchase\")\n            voucher.set(\"ACTION\", \"Create\")\n            \n            # Voucher header\n            ET.SubElement(voucher, \"DATE\").text = self._format_date_for_tally(invoice.invoice_date)\n            ET.SubElement(voucher, \"VOUCHERTYPENAME\").text = \"Purchase\"\n            ET.SubElement(voucher, \"VOUCHERNUMBER\").text = f\"GSTR2B-{voucher_number:04d}\"\n            ET.SubElement(voucher, \"REFERENCE\").text = f\"{invoice.invoice_number} ({invoice.vendor_name})\"\n            ET.SubElement(voucher, \"NARRATION\").text = f\"GSTR2B Purchase from {invoice.vendor_name} - Invoice: {invoice.invoice_number}\"\n            \n            # Determine if interstate\n            is_interstate = self._is_interstate_transaction(invoice)\n            \n            # Vendor ledger entry (Credit side)\n            vendor_name = self._clean_ledger_name(invoice.vendor_name or f\"Vendor-{invoice.vendor_ctin}\")\n            vendor_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n            ET.SubElement(vendor_entry, \"LEDGERNAME\").text = vendor_name\n            ET.SubElement(vendor_entry, \"ISDEEMEDPOSITIVE\").text = \"Yes\"  # Credit\n            ET.SubElement(vendor_entry, \"AMOUNT\").text = f\"-{invoice.invoice_value:.2f}\"\n            \n            # Add bill details\n            if invoice.invoice_number:\n                bill_allocations = ET.SubElement(vendor_entry, \"BILLALLOCATIONS.LIST\")\n                ET.SubElement(bill_allocations, \"NAME\").text = invoice.invoice_number\n                ET.SubElement(bill_allocations, \"BILLTYPE\").text = \"New Ref\"\n                ET.SubElement(bill_allocations, \"AMOUNT\").text = f\"-{invoice.invoice_value:.2f}\"\n                ET.SubElement(bill_allocations, \"BILLDATE\").text = self._format_date_for_tally(invoice.invoice_date)\n            \n            # Purchase ledger entry (Debit side)\n            purchase_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n            ET.SubElement(purchase_entry, \"LEDGERNAME\").text = \"Purchase - Trading Goods\"\n            ET.SubElement(purchase_entry, \"ISDEEMEDPOSITIVE\").text = \"No\"  # Debit\n            ET.SubElement(purchase_entry, \"AMOUNT\").text = f\"{invoice.taxable_value:.2f}\"\n            \n            # Tax entries (Debit side)\n            if is_interstate and invoice.igst_amount > 0:\n                # IGST for interstate\n                igst_rate = self._calculate_tax_rate(invoice.taxable_value, invoice.igst_amount)\n                igst_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n                ET.SubElement(igst_entry, \"LEDGERNAME\").text = f\"Input IGST {igst_rate}%\"\n                ET.SubElement(igst_entry, \"ISDEEMEDPOSITIVE\").text = \"No\"  # Debit\n                ET.SubElement(igst_entry, \"AMOUNT\").text = f\"{invoice.igst_amount:.2f}\"\n            else:\n                # CGST + SGST for intrastate\n                if invoice.cgst_amount > 0:\n                    cgst_rate = self._calculate_tax_rate(invoice.taxable_value, invoice.cgst_amount)\n                    cgst_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n                    ET.SubElement(cgst_entry, \"LEDGERNAME\").text = f\"Input CGST {cgst_rate}%\"\n                    ET.SubElement(cgst_entry, \"ISDEEMEDPOSITIVE\").text = \"No\"  # Debit\n                    ET.SubElement(cgst_entry, \"AMOUNT\").text = f\"{invoice.cgst_amount:.2f}\"\n                \n                if invoice.sgst_amount > 0:\n                    sgst_rate = self._calculate_tax_rate(invoice.taxable_value, invoice.sgst_amount)\n                    sgst_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n                    ET.SubElement(sgst_entry, \"LEDGERNAME\").text = f\"Input SGST {sgst_rate}%\"\n                    ET.SubElement(sgst_entry, \"ISDEEMEDPOSITIVE\").text = \"No\"  # Debit\n                    ET.SubElement(sgst_entry, \"AMOUNT\").text = f\"{invoice.sgst_amount:.2f}\"\n            \n            # CESS if applicable\n            if invoice.cess_amount > 0:\n                cess_entry = ET.SubElement(voucher, \"ALLLEDGERENTRIES.LIST\")\n                ET.SubElement(cess_entry, \"LEDGERNAME\").text = \"Input CESS\"\n                ET.SubElement(cess_entry, \"ISDEEMEDPOSITIVE\").text = \"No\"  # Debit\n                ET.SubElement(cess_entry, \"AMOUNT\").text = f\"{invoice.cess_amount:.2f}\"\n            \n        except Exception as e:\n            logger.error(f\"Error creating purchase voucher for invoice {invoice.invoice_number}: {e}\")\n    \n    def _is_interstate_transaction(self, invoice: GSTR2BInvoice) -> bool:\n        \"\"\"Determine if transaction is interstate based on GSTIN and POS.\"\"\"\n        try:\n            if not invoice.vendor_ctin or len(invoice.vendor_ctin) < 2:\n                return False\n            \n            vendor_state_code = invoice.vendor_ctin[:2]\n            company_state_code = \"07\"  # Assuming Delhi for now, can be dynamic\n            \n            # Check POS (Place of Supply) if available\n            if invoice.pos and invoice.pos != company_state_code:\n                return True\n            \n            # Check if vendor state is different from company state\n            if vendor_state_code != company_state_code:\n                return True\n            \n            # Also check if IGST is present (clear indicator of interstate)\n            return invoice.igst_amount > 0\n            \n        except Exception as e:\n            logger.error(f\"Error determining interstate status: {e}\")\n            return False\n    \n    def _calculate_tax_rate(self, taxable_value: float, tax_amount: float) -> int:\n        \"\"\"Calculate tax rate percentage.\"\"\"\n        if taxable_value <= 0:\n            return 0\n        \n        rate = (tax_amount / taxable_value) * 100\n        return round(rate)\n    \n    def _format_date_for_tally(self, date_str: str) -> str:\n        \"\"\"Format date for Tally (YYYYMMDD).\"\"\"\n        if not date_str:\n            return datetime.now().strftime(\"%Y%m%d\")\n        \n        try:\n            # Input format is YYYY-MM-DD, Tally needs YYYYMMDD\n            if '-' in date_str:\n                dt = datetime.strptime(date_str, \"%Y-%m-%d\")\n                return dt.strftime(\"%Y%m%d\")\n            else:\n                return datetime.now().strftime(\"%Y%m%d\")\n        except Exception as e:\n            logger.error(f\"Error formatting date {date_str}: {e}\")\n            return datetime.now().strftime(\"%Y%m%d\")\n    \n    def _clean_ledger_name(self, name: str) -> str:\n        \"\"\"Clean and format ledger name for Tally.\"\"\"\n        if not name:\n            return \"Unknown Vendor\"\n        \n        # Remove special characters and limit length\n        cleaned = ''.join(c for c in name if c.isalnum() or c.isspace() or c in '-._')\n        return cleaned[:99].strip()  # Tally has ledger name limits\n    \n    def _prettify_xml(self, element: ET.Element) -> str:\n        \"\"\"Convert XML element to prettified string.\"\"\"\n        xml_str = ET.tostring(element, encoding='unicode')\n        xml_declaration = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n'\n        \n        # Basic prettification\n        lines = xml_str.split('>')\n        formatted_lines = []\n        indent_level = 0\n        \n        for line in lines:\n            line = line.strip()\n            if not line:\n                continue\n                \n            if line.startswith('</'):\n                indent_level -= 1\n            \n            formatted_lines.append('  ' * indent_level + line + '>')\n            \n            if not line.startswith('</') and not line.endswith('/>') and '</' not in line:\n                indent_level += 1\n        \n        formatted_xml = xml_declaration + '\\n'.join(formatted_lines)\n        return formatted_xml.replace('>>', '>')\n    \n    def validate_transactions_xml(self, invoices: List[GSTR2BInvoice]) -> Dict[str, Any]:\n        \"\"\"Validate transaction data before XML generation.\"\"\"\n        validation_result = {\n            'valid': True,\n            'errors': [],\n            'warnings': []\n        }\n        \n        if not invoices:\n            validation_result['valid'] = False\n            validation_result['errors'].append(\"No invoices found for Transactions XML generation\")\n            return validation_result\n        \n        # Check for missing invoice numbers\n        invoices_without_number = [inv for inv in invoices if not inv.invoice_number]\n        if invoices_without_number:\n            validation_result['warnings'].append(f\"{len(invoices_without_number)} invoices without invoice number\")\n        \n        # Check for zero value invoices\n        zero_value_invoices = [inv for inv in invoices if inv.invoice_value <= 0]\n        if zero_value_invoices:\n            validation_result['warnings'].append(f\"{len(zero_value_invoices)} invoices with zero or negative value\")\n        \n        # Check tax calculation consistency\n        inconsistent_invoices = []\n        for inv in invoices:\n            calculated_total = inv.taxable_value + inv.cgst_amount + inv.sgst_amount + inv.igst_amount + inv.cess_amount\n            if abs(calculated_total - inv.invoice_value) > 0.01:  # Allow 1 paisa difference\n                inconsistent_invoices.append(inv.invoice_number)\n        \n        if inconsistent_invoices:\n            validation_result['warnings'].append(f\"Tax calculation inconsistencies in invoices: {inconsistent_invoices[:5]}\")\n        \n        # Summary\n        total_value = sum(inv.invoice_value for inv in invoices)\n        total_tax = sum(inv.cgst_amount + inv.sgst_amount + inv.igst_amount + inv.cess_amount for inv in invoices)\n        interstate_count = len([inv for inv in invoices if self._is_interstate_transaction(inv)])\n        \n        validation_result['summary'] = {\n            'total_invoices': len(invoices),\n            'total_invoice_value': total_value,\n            'total_tax_amount': total_tax,\n            'interstate_invoices': interstate_count,\n            'intrastate_invoices': len(invoices) - interstate_count\n        }\n        \n        return validation_result","size_bytes":13742}},"version":1}